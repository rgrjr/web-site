<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Enhanced M-. for ilisp</title>
</head>

<body bgcolor=white>
<h1>Enhanced <tt>M-.</tt> for the <tt>ilisp</tt> package</h1>

<p><a href="/"><tt>Home</tt></a> : <a href="/emacs/">Emacs</a> : <a
href="./"><tt>ilisp</tt></a> : New <tt>M-.</tt>
<hr>

<p><tt>ilisp</tt> is an emacs lisp package that provides an integrated
development interface to various Common Lisp and Scheme implementations,
both commercial and free.  One of its features is the
<tt>edit-definitions-lisp</tt> command, which is bound to <tt>M-.</tt>,
the key sequence which invokes <tt>find-tag</tt> in most editing modes.
Both commands do similar things, bringing the source code for a named
definition under the users fingertips, but one of
<tt>edit-definitions-lisp</tt>'s advantages is that it can ask the
running Lisp for the type and location of any definitions associated
with a given name.  Most Lisps remember the source file from which each
definition was loaded, or can be told to do so.

<p>The code described on this page enhances <tt>ilisp</tt>'s
<tt>M-.</tt> implementation in several ways.  Eventually, it should be
integrated into <tt>ilisp</tt> itself, and this page will go away.

<h2>Table of Contents</h2>

<!-- hhmtoc start -->
<ol>
  <li> Enhanced <tt>M-.</tt> for the <tt>ilisp</tt> package
       <ol>
	 <li> Table of Contents
	 <li> <a href="#intro">Introduction</a>
	      <ol>
		<li> <a href="#terms">Terminology</a>
		<li> <a href="#install">Installation instructions</a>
	      </ol>
	 <li> <a href="#user">User documentation</a>
	      <ol>
		<li> <a href="#meta-point">Lisp and <tt>M-.</tt></a>
		<li> <a href="#buffer">The <tt>*Edit-Definitions*</tt> buffer</a>
		<li> <a href="#nested-definitions">Nested definitions</a>
		<li> <a href="#static-nesting">Statically nested definitions</a>
	      </ol>
	 <li> <a href="#implementation-notes">Implementation notes</a>
	      <ol>
		<li> <a href="#proto">Protocol</a>
		     <ol>
		       <li> Syntax of source locations
		       <li> Lisp semantics of source locations
		       <li> <a href="#emacs-semantics">emacs semantics of source locations</a>
		       <li> <a href="#accessors">Notes on <tt>defstruct</tt> and <tt>defclass</tt> accessors</a>
		     </ol>
		<li> <a href="#notes">Notes</a>
		     <ol>
		       <li> <a href="#search-logic"><tt>lisp-locate-clisp</tt> search logic</a>
		     </ol>
	      </ol>
	 <li> <a href="#further-work">Further work</a>
	      <ol>
		<li> Things to do
		<li> <a href="#issues">Issues</a>
		     <ol>
		       <li> <a href="#lisp-edit-files">Issue 1: Possible loss of <tt>lisp-edit-files</tt> fallback</a>
		       <li> <a href="#packaging">Issue 2: Packaging into <tt>"*.lisp"</tt> sources</a>
		     </ol>
		<li> <a href="#deferred-features">Deferred features</a>
	      </ol>
	 <li> <a href="#references">References</a>
       </ol>
</ol>
<!-- hhmtoc end -->

<a name=intro>
<h2>Introduction</h2>

This patch has been tested on the CVS version of <tt>ilisp</tt> using
emacs&nbsp;20.7 (compiled for GNU/Linux on x86) and the following Lisp
implementations:
<ul>
  <li> CMUCL 18d.  (Earlier versions probably also work.)
  <li> Allegro 6.1, ANSI version.  (ACL 6.0 and 6.2 probably also work;
       ACL 5.0.1 and earlier versions may work but probably need
       <tt>ilisp-pkg.lisp</tt> tweaks.  Case-sensitive versions may
       work, to some extent.)
  <li> SBCL 0.7.6 (to a lesser extent).
</ul>
It should also run on top of <tt>ilisp</tt>&nbsp;5.12.0 without
problems.

<p>For other Lisp implementations, installing this patch will not
improve things, and may degrade your Lisp experience, unless you are
willing to do some work to teach your Lisp about the new protocol.
Beyond that, be advised that this patch is "alpha" software, and liable
to degrade your Lisp experience for other reasons.

<p>New features:
<ul>
  <li> <tt>M-.</tt> (at least for the Lisps named above) now gets more
       source code information out of the Lisp, and uses it more
       effectively to narrow the code search, and so should be faster
       and more successful at finding the right place in the source.
  <li> <tt>M-.</tt> does not always need to prompt for a definition
       type.  Instead, it queries the Lisp for all definition types
       known for that name.  If there is only one definition type,
       <tt>M-.</tt> assumes you want that one, and doesn't bother to
       query; if more than one, you are offered a choice of the actual
       defined types, plus <tt>"any"</tt> to get them all.
  <li> Definition names and types are listed explicitly in the
       <tt>*Edit-Definitions*</tt> buffer, which makes it easier to
       visit them selectively.
  <li> <tt>*Edit-Definitions*</tt> now includes the name of the
       <tt>ilisp</tt> dialect that was queried, and uses it in the "No
       more definitions" message, which is quite helpful if you run more
       than one dialect concurrently.
  <li> Asking <tt>M-.</tt> for <tt>"any"</tt> type of definition now
       enumerates all the possibilities known to the Lisp.  For this
       reason, <tt>"any"</tt> is now the default definition type.
  <li> Similarly, asking for the function definition of a generic
       function name now enumerates all the methods, returning names
       like <tt>"(method&nbsp;foo&nbsp;(bar&nbsp;t))"</tt>.
  <li> It is now possible to give <tt>M-.</tt> these compound names,
       including Common Lisp
       <tt>"(setf&nbsp;somewhere-over-rainbow)"</tt> function names as
       well as methods.  In PCL-derived CLOS implementations, you can
       also <tt>M-.</tt> using the symbols generated internally by PCL
       for method functions.  (Some previous method-finding heuristics
       existed, but they used a nonstandard syntax; I don't honestly
       know how well they worked.)
  <li> When <tt>M-.</tt> or <tt>M-,</tt> moves to a new definition in
       the current buffer, it now does <tt>push-mark</tt>, making it
       easy to navigate back.
  <li> Each found definition is now repositioned in the window by
       <tt>reposition-window-lisp</tt>, which makes leading comments and
       reader conditionalization visible.
  <li> Structure and CLOS slot accessor functions are now found by
       looking for the containing "parent" definition, where the Lisp
       can extract the parent's name and type.
  <li> <tt>M-.</tt> now works for all structure accessors, even in ACL,
       which is an implementation that can't determine the structure
       name of an accessor function (but <a
       href="#no-sbcl-struct-accessors">see the caveat below</a>).
       Previously, there was a heuristic that worked in some cases; the
       heuristic is now much improved, and only used when necessary.
  <li> When a slot accessor is found, the cursor is placed at the
       beginning of the matched slot or accessor name, with the top of
       the definition shown at the top of the window, window size
       permitting.
  <li> Many of the regular expressions were made more specific, which
       should result in fewer "false positives."  Others were made more
       general, to avoid being confused by package name aliases (though
       this strategy is not used consistently, alas).  And nearly all of
       them were expressed in terms of a few standard idioms, for
       readability.
  <li> <tt>M-.</tt> reports symbol package names as they are printed by
       the Lisp implementation.
  <li> A new variable, <tt>lisp-fall-back-on-find-tags</tt> [sic]
       controls whether to use <tt>find-tag</tt> if no definitions can
       be found by asking the Lisp.  Possible values are <tt>t</tt>,
       <tt>nil</tt>, and <tt>:ask</tt>; the default is <tt>:ask</tt>.
       (Since <tt>M-.</tt> is now much more likely to succeed, perhaps
       the default should be <tt>nil</tt>.)
</ul>

<p>New misfeatures:
<ul>
  <li> Setting <tt>lisp-edit-files</tt> to <tt>t</tt> no longer works if
       the Lisp can't produce source information.  See the <a
       href="#lisp-edit-files">Issue 1: Possible loss of
       <tt>lisp-edit-files</tt> fallback</a> section.
  <li> In a similar vein, <tt>search-lisp</tt> no longer works, either.
       But I posted a message titled 'PATCH: "bad format string" error
       for search-lisp "found" message' to
       <tt>ilisp-devel@lists.sourceforge.net</tt> on 18-Sep-2002 with a
       fix for a <tt>search-lisp</tt> bug, and added the following
       comments:
       <blockquote>
       Due to this bug, it appears that every hit of any search is
       greeted with a "Not enough arguments for format string" error.
       This seems to have been broken "forever," so I would be tempted
       to conclude that nobody uses <tt>search-lisp</tt>, especially
       since <tt>M-x&nbsp;grep</tt> is much more featureful when
       groveling through sources.  But the search-lisp functionality is
       not actually impacted much by this error, since the hit is
       already in the window at this point, so it's hard to be sure that
       this feature is really ripe for GC.

       <p>However, unless somebody complains, I will not waste time on
       keeping <tt>search-lisp</tt> working when developing
       <tt>ilisp-src.el</tt> <tt>M-.</tt> enhancements.
       </blockquote>
       
       <p>[there may be other <tt>search-lisp</tt> and/or
       <tt>replace-lisp</tt> breakage due to incompatible buffer syntax,
       though.  -- rgr, 9-Sep-02.]
  <li> In order to unify the MOP-using code, the <tt>ILISP</tt> package
       now uses the various incompatibly-named CLOS and MOP packages as
       appropriate.  This may not be to everyone's taste, but it cuts
       down on the amount reader conditionalization necessary to get all
       of the new Lisp-end implementation to live in one file.  (This
       also might not suit some people, but it cuts down on the code
       volume, and makes it much easier to develop.)
  <li> The CMUCL <tt>find-src.lisp</tt> code now depends heavily on PCL;
       you can build a CMUCL image without PCL (which makes it
       non-ANSI), but you can't use <tt>ilisp</tt> to talk to this
       image.  (This may have been the case before, but it would be much
       harder to fix it to use this patch.)
</ul>

<a name = terms>
<h3>Terminology</h3>

In the <a href="#implementation-notes">Implementation notes</a> section,
I often need to distinguish between the part of <tt>ilisp</tt>
implemented in Lisp (which I refer to as "Lisp"), and the part
implemented in emacs (which I call "emacs").  In order to avoid
confusion in the <a href="#user">User documentation</a> section, I lump
them both together as <tt>"ilisp"</tt>.

<p>[Unfortunately, my preferred style for marking up the package name,
<tt>"ilisp"</tt>, conflicts with the documentation, which uses "ILISP".
-- rgr, 23-Sep-02.]

<a name=install>
<h3>Installation instructions</h3>

These instructions assume you already have <tt>ilisp</tt>, preferably <a
href="http://sourceforge.net/projects/ilisp/">a recent CVS version</a>,
installed somewhere.
<ol>
  <li> Unpack the tarball into a suitable location.
  <li> In your <tt>.emacs</tt> file, arrange to have this directory
       added to your <tt>load-path</tt> <i>before</i> the directory that
       contains <tt>ilisp</tt>.  Once you do this, all existing autoload
       declarations as well as any explicit
       <tt>"(require&nbsp;'ilisp)</tt> calls will get the patched
       version.
  <li> The <tt>".elc"</tt> files are precompiled using FSF emacs 20.7,
       but if your emacs version can't load these, you will need to
       recompile them by hand.  It should just work to blow away the
       <tt>".elc"</tt> files.
  <li> In a fresh emacs, fire up your favorite Lisp implementation.
  <li> Do <tt>"M-x ilisp-compile-inits"</tt>.  If the install worked,
       you should also see <tt>"find-src.lisp"</tt> getting compiled.
       You may see a warning like the following:
       <pre>
       ;;;Compile /usr/share/emacs/ilisp-cvs/cmulisp

       In: LAMBDA (STRING PACKAGE-NAME)
	 (ILISP-FIND-PACKAGE PACKAGE-NAME :ERROR-P NIL)
       Warning: Function called with three arguments, but wants exactly one.
</pre>
       This is OK, as the offending definition is overridden by the
       <tt>find-src.lisp</tt> version.
</ol>
To uninstall, simply remove the directory from <tt>load-path</tt> (and
restart emacs, of course).  It is not necessary to redo the
<tt>"M-x&nbsp;ilisp-compile-inits"</tt>.

<p>
<hr>
<a name=user>
<h2>User documentation</h2>

[The current documentation doesn't say much about how definitions are
found.  Accordingly, this material could be adapted as a preface.  Some
of it may be more appropriate as an appendix.  -- rgr, 5-Sep-02.]

<p>[It might be nice to have a "troubleshooting" section:  What to do if
<tt>M-.</tt> doesn't find the definition(s) you think it should.  Best
to write this after the new functionality is stable.  -- rgr, 5-Sep-02.]

<p>[Since <tt>M-.</tt> is documented together with
<tt>edit-callers-lisp</tt>, as both have a similar user interface, it
would be nice if the latter could be updated to use the new protocol
implementation before updating the documentation.  Maybe that should be
a necessary condition of releasing <tt>ilisp</tt> after merging this
patch?  -- rgr, 5-Sep-02.]

<a name=meta-point>
<h3>Lisp and <tt>M-.</tt></h3>

Lisp has a long tradition of providing a "source-rich" environment,
undoubtedly dating back to Lisp's origin as an interpreted language used
by the Artificial Intelligence community.  Sharing source is especially
important for research, and hence it is useful for research programmers
in particular to be able to navigate through unfamiliar shared source
code.  For the earliest Lisp implementations, this was not a problem;
programs tended to be small, so it was reasonable to pore through the
line printer listing of a program by hand.

<p>As Lisp systems grew and became more complicated, and as interactive
timeshared systems became the norm for academic software,
perusing hardcopy became less practical.
With the development of compilers, themselves large applications written in
Lisp, it was no longer possible for an interactive Lisp system to show a
"pretty-printed" version of the interpreted definition.
The need therefore grew for help from the text editor in locating
definitions in source code.

<p>[This is the "MACLISP era" of Lisp evolution, about which I have no
firsthand experience, and can't find much on the Web.  Here are a couple
of useful references, though:
<ol>
  <li> <a href="#Emacs1979">Stallman's 1979 emacs paper</a>, in which he
       describes the <tt>find-tag</tt> command, but says nothing about
       the state-of-the-art.
  <li> Bernard S. Greenberg, <a
       href="http://www.multicians.org/mepap.html"> Multics Emacs: The
       History, Design and Implementation</a>, 1979, in which Lisp is
       introduced as an implementation/extension language for emacs.
  <li> <a href="http://www.multicians.org/features.html#tag1.7.10">
       Multics Maclisp</a>, describing the features of the Lisp in which
       Multics Emacs was implemented.
</ol>
I find this fascinating, but don't have the time to research it now.  If
you are aware of any other relevant links, please email them to me.  --
rgr, 13-Sep-02.]

<p>In emacs, <tt>M-.</tt> has always been the traditional keybinding for
the <tt>find-tag</tt> command that locates a definition in the source
code given its name <a href="#Emacs1979">[Emacs1979]</a>.  In most
modes, <tt>M-.</tt> still invokes an evolved edition of
<tt>find-tag</tt>, which is still dependent on the <tt>etags</tt>
command for creating the <tt>"TAGS"</tt> files that effectively serve as
an index to the source code.

<p>Lisp has evolved considerably since the early days, and modern Lisps
have a number of features that complicate the process of finding
definition sources:
<ul>
  <li> Definition names are not necessarily symbols.
  <li> Some definition names, defstruct slot accessors in particular,
       never appear explicitly in the source form that defines them.
  <li> Some definition types that are named by symbols, generic
       functions in particular, are potentially multipart.  In other
       words, a single name may map to multiple definitions.
  <li> Many applications add their own set of definition macros, some of
       which may have nontrivial syntax and/or naming.
</ul>
All four of these complications tend to make the simple string searching
tactic of <tt>find-tag</tt> inadequate.  Fortunately, Lisp excels at <a
href=#amop">"introspection"</a> (though unfortunately not always in
portable ways), so it is usually possible to query a running Lisp about
what definitions have been loaded into it, and often possible to find
out the source files names for a given definition as well.  It is
therefore advantageous to query the Lisp about what it knows best, and
leave the file finding and definition searching to emacs.

<p>[should say something about M-. interaction here, plus some details
of the internal processes.  -- rgr, 19-Sep-02.]

<a name=buffer>
<h3>The <tt>*Edit-Definitions*</tt> buffer</h3>

All of the definition and file name information retrieved from the Lisp
is put into the <tt>*Edit-Definitions*</tt> buffer, effectively making
the communication between emacs and the Lisp concrete and accessible to
the user.  This has a number of advantages:
<ul>
  <li> If there are multiple definitions, subsequent <tt>M-,</tt>
       (<tt>next-definition-lisp</tt>) commands can find them by working
       through the buffer.
  <li> The "next" definition found by <tt>M-,</tt> is the one on the
       line with the point; by moving point, <tt>M-,</tt> can access
       definitions randomly.
  <li> As a last resort, if there are problems with the file names
       returned by the Lisp (i.e. undefined logical pathname
       translations), the user can manually edit the file names to
       something meaningful on the local system.
</ul>
In essence, <tt>*Edit-Definitions*</tt> is like a mini <tt>TAGS</tt>
buffer, created on the fly for a single definition at a time.

<p>[really need to describe syntax in detail, in order to make editing
more useful.  -- rgr, 19-Sep-02.]

<a name = nested-definitions>
<h3>Nested definitions</h3>

One factor that complicates locating the source for a given definition
is that Common Lisp applications often have their own macros for
creating application-specific defintion types.  Some such macros are
intended for internal use, when implementing the application, but others
are part of the application's public interface.

<p>Many of these expand into other Common Lisp definition forms.
[elaborate]

<p>This problem even occurs in "pure" ANSI Common Lisp.  For example,
whenever a <tt>defstruct</tt> is defined, many Common Lisp
implementations also define a "structure class" in order to support CLOS
method dispatch on structure types; if this structure class has an
associated source file name (as it does in PCL-derived CLOS
implementations), it will appear as if there is both a
<tt>defstruct</tt> form and a <tt>defclass</tt> form, when really the
<tt>defstruct</tt> was responsible for creating both.  If <tt>ilisp</tt>
is not told about this relationship, then doing <tt>M-.</tt> on a
structure name can fail, in either of two ways:
<ol>
  <li> If source file name recording for <tt>defstruct</tt> forms is not
       supported, or not enabled, then only the structure class will
       show up, but <tt>ilisp</tt> will be unable to find
       <tt>"(defclass&nbsp;<i>structure-name</i>&nbsp;...)"</tt> in the
       source, because it doesn't exist.
  <li> If source file name recording for <tt>defstruct</tt> forms is
       supported and enabled, then both definitions will be reported,
       even though they really refer to the same source (and
       <tt>ilisp</tt> still won't be able to find a <tt>defclass</tt>
       form).
</ol>
Since existence of the structure class is really an artifact of a fairly
standard CLOS implementation technique, <tt>ilisp</tt> does "the right
thing" by simply suppressing source file information for the structure
class.

<p>[In fact, because of other implementation quirks, the
structure/structure-class thing is not an issue.  See the
<tt>ilisp::make-structure-or-class-definition-spec</tt> function and the
<tt>try-excl-source-file</tt> lexical function below it for the
(implicit) reasons.  -- rgr, 19-Sep-02.]

<p>However, there are other situations where it is important to make
definition nesting information available to <tt>ilisp</tt>.  The most
important of these are structure and CLOS slot accessors, which are
indistinguishable from functions at the point of call, but are defined
incidentally <tt>defstruct</tt> and <tt>defclass</tt> forms,
respectively.  If <tt>ilisp</tt> can figure out that it has a slot
accessor function, and can determine the name of the
containing structure (this is usually trivial for classes), the source
definition of the structure or class will be found instead, after
printing a message that looks something like this:
<blockquote>
<pre>
:Function PKG::FOO-SLOT1 is inside the definition of :Structure PKG::FREELY-ORIENTED-OBJECT
</pre>
</blockquote>
However, if you get a message like one of the following:
<blockquote>
<pre>
:Function PKG::FOO-SLOT2 is inside a PKG::FREELY-ORIENTED-OBJECT definition
:Function PKG::FOO-SLOT3 is inside some :Structure definition
:Function PKG::FOO-SLOT4 is inside another definition.
</pre>
</blockquote>
then <tt>ilisp</tt> was unable to completely determine the name and type
of the containing definition.  However, all is not lost; in this case,
<tt>ilisp</tt> will employ extra search heuristics to try to locate this
definition, and will in any case switch to the appropriate source buffer
so you can search for it manually if necessary.

<p>Hint:  You can switch on the full search heuristics manually by
adding <tt>"!! is inside another definition"</tt> on a line by itself
before the problem definition.  (Adding just <tt>"!!"</tt> on a line by
itself also works, but results in a "can't parse" message.)  Then, move
the cursor to the start of this line, return to your Lisp buffer, and
invoke <tt>next-definition-lisp</tt> (<tt>M-,</tt>).

<a name = static-nesting>
<h3>Statically nested definitions</h3>

[<b>Note:</b> This is not yet implemented.  Due to various
implementation quirks, the structure/class ambiguity was addressed in
different ways.  -- rgr, 16-Sep-02.]

<p>This section describes how to teach <tt>ilisp</tt> to recognize
simple nested definition relationships, and can be skipped on a first
reading.  It is not necessary to read this section in order to use
<tt>ilisp</tt>.

<p>Note that the structure/class case mentioned above is easy to
recognize (and so is the <tt>clim:define-command</tt> case illustrated
below) because both of the following are true:
<dl compact>
  <dt> (a)
  <dd> The parent and child definitions share the same name; and
  <dt> (b)
  <dd> The parent/child relationship is unconditional, i.e. the
       existence of source information for both parent and child always
       means that one was created by the other.
</dl>
When both of these hold true, then the parent/child relationship is a
static property of the definition types, and can be described with a
static database relating definition type names.

<p>In <tt>ilisp</tt>, static parent/child definition relationships are
described within the Lisp process (i.e. not emacs) by the
<tt>:static-definition-children</tt> property of the parent definition
form name.  The value of this property should be a list of other
definition names which, if present, are certain to be produced as a
result of evaluating a parent definition form, obeying the two
constraints listed above.  If <tt>ilisp</tt> sees a definition with a
type that has a <tt>:static-definition-children</tt> property, then it
will be merged with any definitions of any of the listed types.  [need
to think carefully about how to do the merging.  -- rgr, 5-Sep-02.]
Note that this requires source file recording for the parent type, which
may not be supported for arbitrary application definition types.
Without having source information for the parent, it is in general not
possible for <tt>ilisp</tt> to determine that a given <tt>defun</tt>
needs to be merged with something else, especially since there are
usually many definitions that expand into <tt>defun</tt> forms without
leaving much trace.  [Which is why <a href="#protocol-extensibility">
protocol extensibility</a> is important.  -- rgr, 5-Sep-02.]

<p>This mechanism was designed to be simple so that it can be used by
other subsystems and applications, with or without <tt>ilisp</tt>
customizations.  As another example, the CLIM user interface subsystem
defines <tt>clim:define-command</tt> as a macro that expands into an
ordinary <tt>defun</tt> form that implements the command semantics,
using the body of the <tt>clim:define-command</tt> form, plus additional
magic that allows the function to be used as a CLIM command.  The
following (Common Lisp) form tells <tt>ilisp</tt> this fact:
<blockquote>
<pre>
(setf (get 'clim:define-command :static-definition-children) '(defun))
</pre>
</blockquote>
Note that this can be done by a user or application program, if missing
in the CLIM subsystem.  Note also that <tt>clim:define-command</tt>
expands into a parser function, and sometimes other top-level functions,
in addition to the body function; the other functions are more
troublesome to deal with because of one or both of the static definition
nesting constraints is violated, but their existence does not invalidate
the static nesting of the "main" <tt>defun</tt> that executes the
command.

<p>[transitive nesting is not handled right at present.  -- rgr,
6-Sep-02.]

<p>
<hr>
<a name=implementation-notes>
<h2>Implementation notes</h2>

This implementation tries to follow that of Zmacs, the emacs-like text
editor originally developed for the MIT Lisp Machine and later
commercialized by Symbolics and LMI/Texas Instruments.  In all of the
Lisp Machine derivatives, all processes run in a single shared address
space, so Zmacs (which is implemented in Lisp) has direct access to all
Lisp data structures, with effectively infinite bandwidth.  Since the
bandwidth <tt>ilisp</tt>'s channel between the Lisp and emacs is not
infinite, we must be more careful, and try to use the bandwidth
efficiently.  However, machines and networks are much faster these days,
so we try not to worry too much about communication overhead.

<p>Accordingly, this patch "widens the pipe" from the Lisp system.  When
given a generic function name, for example, the Lisp enumerates and
returns the names and source files of all methods, preceded with the
name and source file of the defgeneric form, if any.  The existing code
just enumerates the methods' source files, which is useful without
knowing the method names only if you want to visit all method
definitions in source order.

<p>When finding a method definition, ilisp therefore has the full method
name as known to the Lisp.  That makes it possible to construct a very
specific regular expression to find only that method, which is used to
search only that file.  This in turn makes random access of the
<tt>*Edit-Definitions*</tt> buffer useful.

<p>The enumeration of GF methods is just a special case of returning
source locations for all matching definitions associated with the
symbol, e.g. variables, functions, CLOS classes, etc.  As a result, the
<tt>"any"</tt> definition type now really means "all", and is more
featureful.  (I notice that looking for <tt>"any"</tt> using the current
<tt>ilisp</tt>&nbsp;5.12.0 release often blows out the regexp stack in
emacs&nbsp;20.7, presumably because it is trying to search for all
possible definitions of a symbol in parallel.  This is not necessary
when emacs gets <tt>(name type file)</tt> triples handed to it on a
silver platter.)  Consequently, I've made <tt>"any"</tt> the default.

<p>Because of this, <tt>edit-definitions-lisp</tt> now omits the prompt
for the definition type if can find only one, as should be the case for
most definitions in user code.  A generic function with a single method
is now found as easily via the GF name as if it were a defun, which
conceptually it is.

<a name=proto>
<h3>Protocol</h3>

In order to support this added functionality, the return value that
<tt>edit-definitions-lisp</tt> expects from <tt>ilisp:source-file</tt>
must be extended to more than a list of pathnames.  First we describe
the syntax, then we divide up the labor into what the Lisp
implementation should and should not do to generate it, and what
<tt>ilisp</tt> should and should not do internally to present it to the
user.

<h4>Syntax of source locations</h4>

The result is a list in a syntax that is a subset of what the Common
Lisp printer normally produces with <tt>*print-escape*</tt> bound to
true.  Symbols are allowed (indeed, encouraged) to have package
prefixes; emacs lisp treats <tt>":"</tt> as a normal constituent
character.  Symbols, strings, "small" numbers, and (recursively) lists
of the above are therefore acceptable.  (Currently, numbers are not
used, so it is not necessary to define "small.")

<p>Since emacs lisp can't deal with the full CL reader syntax, the
following must be avoided:
<ol>
  <li> Any use of <tt>"#"</tt> as a reader macro.
  <li> Circular structures.
  <li> Bignums (and watch out with floats).
</ol>

<p>Other Common Lisp constituent characters such as <tt>"?"</tt>, and
(interior to a symbol name) <tt>"#"</tt> must be escaped by emacs in
order to be parsed correctly as emacs symbols.  [I have not yet tested
vertical bars, which is almost certain to screw things up.  -- rgr,
19-Sep-02.]

<blockquote>
<pre>
&lt;goal&gt;  ::= ( { &lt;item&gt; }* )

&lt;item&gt;  ::= (:comment { &lt;quoted-string&gt; }* )
        ::= &lt;definition&gt;
        ::= &lt;hint&gt;

&lt;definition&gt;
        ::= (:definition { &lt;defn-keyword-value-pair&gt; }* )

&lt;defn-keyword-value-pair&gt;
        ::= :type &lt;type-name&gt;
        ::= :name &lt;definition-name&gt;
        ::= :parent &lt;definition&gt;
	::= :files ( { &lt;file-name&gt; }* )
        ::= :comment ( { &lt;quoted-string&gt; }* )

&lt;definition-name&gt; ::= &lt;expr&gt;

&lt;type-name&gt;
        ::= :function | :macro | :variable | :structure | :type | :class
        ::= &lt;symbol&gt;

&lt;file-name&gt; ::= &lt;quoted-string&gt;

&lt;hint&gt;  ::= ???

</pre>
</blockquote>
The basic structure is therefore a list of sublists, where each sublist
starts with a tag symbol, followed by additional data, usually in the
form of alternating keyword and value pairs.  Alphabetic case is
whatever the Lisp system wants to use for printing.  Case is unimportant
for the symbols shown literally above.  If the source files might be in
a different case, <tt>ilisp</tt> is responsible for constructing
case-insensitive regular expressions.  (Currently, <tt>ilisp</tt>
assumes that all Common Lisp implementations are ANSI-compliant, and
therefore case-insensitive.  If you have two definitions distinguished
only by case, you will lose.)

<p>[As in CL, <tt>"()"</tt> in the grammar can be represented as the
atom <tt>"nil"</tt>, but I'm not sure the code always handles the case
issue correctly.  -- rgr, 19-Sep-02.]

<p>For comments, including those within definitions, each string within
the <tt>:comment</tt> form is conventionally interpreted as its own
line.  Strings are not expected to have newlines.

<p>Here are the particulars of the <tt>&lt;definition&gt;</tt> subform
options:

<dl>
  <dt> <b>:type &lt;type-name&gt;</b>
  <dd> Denotes the type of definition being described; this is required
       because the query type might have been specified as
       <tt>:any</tt>, in which case emacs won't know which type or types
       are actually defined.  The standard names are <tt>:function</tt>
       (includes <tt>defun</tt> and <tt>defmacro</tt>),
       <tt>:macro</tt> (<tt>defmacro</tt> only),
       <tt>:generic-function</tt> (<tt>defgeneric</tt> only),
       <tt>:variable</tt> (<tt>defvar</tt>, <tt>defconstant</tt>, and
       <tt>defparameter</tt>), <tt>:structure</tt> (<tt>defstruct</tt>),
       <tt>:type</tt> (<tt>deftype</tt>, and <tt>:class</tt>
       (<tt>defclass</tt>).  These names, as well as the fact that
       <tt>:function</tt> does not subsume <tt>:macro</tt>, are
       historic; it would probably be better to use the name of the
       defining symbol instead, where known, and the "generic" keyword
       symbol if only the broad definition category is known.  If a
       <tt>&lt;type-name&gt;</tt> is specified that is not one of these,
       it is assumed to be the defining symbol.  (Another historic case,
       <tt>:setf</tt>, has been merged with <tt>:function</tt>, since
       <tt>":setf&nbsp;foo"</tt> is better specified as
       <tt>":function&nbsp;(setf&nbsp;foo)"</tt>.)
  <dt> <b>:name &lt;definition-name&gt;</b>
  <dd> The definition name is usually either a symbol, or a cons of a
       symbol and a list containing other symbols and lists.  This is
       required, except in the case of a parent definition for which we
       can't determine the name.

       <a name = defn-parent-attr>
  <dt> <b>:parent &lt;definition&gt;</b>
  <dd> Specifies another definition within which the current definition
       was defined as a side effect; if this form is present, then the
       current definition does not actually appear in the source.  The
       is used for such things as <a href="#accessors">
       <tt>defstruct</tt> and <tt>defclass</tt> accessors</a>, which are
       functions defined implicitly by these forms.  The full
       defininition form is of course most desirable; since only the
       last definition in a chain of <tt>:parent</tt>s could possibly be
       present in the source, an incomplete parent definition is a hint
       that emacs needs to work harder to find it.  If the
       <tt>:parent</tt> contains no <tt>:files</tt>, then emacs should
       use the <tt>:files</tt> of the containing child.
  <dt> <b>:files ( { &lt;file-name&gt; }* )</b>
  <dd> These are the source file names, one per string.  Note that it is
       possible to specify zero or more filenames for each definition.
  <dt> <b>:comment ( { &lt;quoted-string&gt; }* )</b>
  <dd> Specifies a comment that pertains to this particular definition,
       instead of the collection of definitions as a whole.  It is
       contained within the <tt>&lt;definition&gt;</tt> form so that it
       stays with the right definition if emacs decides to reorder
       things.
</dl>

<h4>Lisp semantics of source locations</h4>

The job of the <tt>ilisp:find-source</tt> implementation should be to
shovel back as much information as possible, and let the emacs portion
of <tt>ilisp</tt> worry about what's relevant to the user.

<p>In more detail:
<dl>
  <dt> Be thorough:
  <dd> The Lisp should enumerate all definitions matching the search
       criteria, even if no pathname is defined for them.  The decision
       for what "matches" should be interpreted liberally; if given a
       generic function name, for example, the Lisp should enumerate the
       names and source files of all methods, preceded with the name and
       source file of the <tt>defgeneric</tt>, if any.  If the item
       <pre>
       (:DEFINITION :TYPE :GENERIC-FUNCTION :NAME PKG::FROBULATE :FILES NIL)
</pre>
       appears in the result, it means that there is an explicit
       <tt>defgeneric</tt> for <tt>pkg::frobulate</tt> somewhere, but we
       couldn't determine the source file name.  If there is no such
       <tt>defgeneric</tt> form, then such a line must <b>not</b>
       appear, even if the generic function is defined (as in
       <tt>fboundp</tt>) because it has methods.
  <dt> Return all file names:
  <dd> Currently, no Lisp supported by <tt>ilisp</tt> remembers multiple
       source file names per definition [AFAIK].  We leave room for this
       possibility because at least one Lisp (on the Symbolics Lisp
       Machine) used it to remember a main source file definition and
       zero or more additional "patch file" versions.  This was useful
       because either kind of source file might not be available, or
       might be out of date, so it was helpful to be able to ask to see
       them all.
  <dt> Return real file names if possible:
  <dd> The Lisp should always attempt to return the <tt>namestring</tt>
       of the <tt>truename</tt> of each source file it uncovers; this is
       mostly to prevent <tt>ilisp</tt> from having to figure out
       logical pathnames and CMUCL search lists.  However, if the file
       doesn't exist, the Lisp should still return whatever string it
       can, since the user may know how to fix it.
  <dt> Identify function parents when possible:
  <dd> This is important for <a href="#accessors"> <tt>defstruct</tt>
       and <tt>defclass</tt> accessors</a>, which are difficult to
       locate otherwise.
</dl>

<p>Currently, if no definitions are found, the result consists solely of
a comment to that effect.  [This is an opportunity for <a
href="#package-dwim">package DWIM</a>.  -- rgr, 19-Sep-02.]

<a name = emacs-semantics>
<h4>emacs semantics of source locations</h4>

Within emacs, <tt>ilisp</tt> is free to mung the result, within limits.

<dl>
  <dt> Everything goes into the <tt>"*Edit-Definitions*"</tt> buffer as
       text.
  <dd> This allows the user to examine, reorder, and fix problems with
       the reported source locations.  There must be no hidden state
       (i.e. buffer-local variables) to interfere with any user edits.
       In the future, we might make exceptions for certain kinds of
       pervasive hints to avoid having to reparse them at every
       <tt>M-,</tt> call, but this should be avoided if at all possible.
  <dt> Comments
  <dd> are saved as such, and echoed as informational messages when
       working through the buffer.  This gives the Lisp implementation
       an opportunity to explain why it couldn't find something, without
       requiring that emacs be able to parse the explanation.  [Also
       returning a symbolic or numeric error code might be a good idea
       though.  -- rgr, 19-Sep-02.]
  <dt> Definitions
  <dd> are generated one line per file, except that a comment is created
       if there are no files.  [unfortunately, that makes it hard for
       the user to supply a file manually.  -- rgr, 9-Sep-02.]
       Information about parents, if incomplete, is used to generate a
       "parent hint" on the preceding line, starting with <tt>"!!"</tt>
       to flag it as such.  [need to describe the syntax of this.  --
       rgr, 19-Sep-02.]  If parent information is complete, the parent
       <i>replaces</i> the child, with the original child described in a
       preceding comment.  The in-buffer syntax is kept simple to make
       it easy to reparse with regular expressions.
  <dt> Order of items
  <dd> should be preserved unless there is a good reason to change it.
       If the order is changed, care should be taken to keep comments
       together with the things they describe.  (That is why there is
       room for comments inside the definitions to which they pertain.)
       [Originally, the order of <tt>"any"</tt> items was controlled by
       the <tt>ilisp::*known-definition-types*</tt> variable, but this
       doesn't work in the face of user-extensible definition types.  --
       rgr, 30-Aug-02.]
</dl>

<a name = accessors>
<h4>Notes on <tt>defstruct</tt> and <tt>defclass</tt> accessors</h4>

These are a pain because they are functions that are defined implicitly
by other top-level definition forms.  In particular, <tt>defstruct</tt>
slot accessors are the hardest case.  Due to the <tt>:conc-name</tt>
option, it is not possible to discover the parent structure name
directly from the slot accessor name within emacs, and not even possible
to do so portably within Lisp.  It is therefore important for the Lisp
to do all it can to determine accessor function parentage.

<p>The Lisp should use partial <a href="#defn-parent-attr">
<tt>:parent</tt> definition specifications</a> to deliver whatever
information it knows about the parent definition form.  If the value is
merely <tt>"(:definition)"</tt> (in any alphabetic case), then that
means that there is a parent definition of some kind, but the Lisp is
unable to determine anything about it.  (Of course, the <tt>:files</tt>
list must be the same as for the child definition, but emacs doesn't
care; it will use the parent's <tt>:files</tt> list for both if not NIL,
else the child's list.)  A more common <tt>:parent</tt> value example
might be <tt>"(:definition :type :structure)"</tt> for a
<tt>defstruct</tt> accessor function, where the Lisp knows that it's a
structure accessor but can't figure out the structure name.  [This is
what is presently returned for ACL.  -- rgr, 5-Sep-02.]

<p>If the Lisp implementation is completely incapable of determining
even the existence of a parent for one of the definitions it is
returning, it should tell emacs via an appropriate hint.  The hint will
instruct emacs always to look for structure accessors when it can't find
an ordinary defun.  [hints not yet implemented, but returning a partial
<tt>:parent</tt> definition should work for most cases for the time
being.  -- rgr, 6-Sep-02.]

<p>Class slot accessor functions are easier for two reasons.  First, the
name of the accessor function appears directly in the <tt>defclass</tt>
form.  Second, the class name appears in the method spec returned to
emacs.  It is therefore sufficient to search for a <tt>defclass</tt>
form of the named class, and then for a reader/writer/accessor clause
naming the generic function within the class body.  The only trick is
knowing when to do this.  The current implementation takes the shortcut
of always searching for an accessor name in parallel with the
<tt>defmethod</tt> search by tacking on a regexp alternative (see the
<tt>lisp-make-cl-method-definition-regexp</tt> function).  However, this
doesn't ensure that we get the accessor in the right class, so the
technique described above would be more precise.

<a name = notes>
<h3>Notes</h3>

<a name = search-logic>
<h4><tt>lisp-locate-clisp</tt> search logic</h4>

The existing <tt>lisp-locate-clisp</tt> implementation uses the
following logic:
<blockquote>
<pre>
(or (re-search-forward rx1 nil t)
    (re-search-forward rx2 nil t)
    (re-search-forward rx3 nil t)
    ...)
</pre>
</blockquote>
The various <tt>"rx<i>i</i>"</tt> are heuristics for (some of which may
or may not actually apply to the definition type we are seeking).  This
suffers from the drawback that any hits to <tt>rx2</tt> or <tt>rx3</tt>
that come before the first hit to <tt>rx1</tt> will be missed
completely.  That's not a problem if we can assume that the sought-after
definition appears at most once per buffer, or always appears in the
same form in the buffer.  However, this same code is also used for "find
all occurrences" situations, such as finding all methods of a generic
function, and we still have to do something of the sort when the Lisp
can't enumerate methods for us.  This searching <a
href="#lisp-edit-files">ought to be done elsewhere</a>.

<p>[If we do get rid of the "find all occurrences" stuff, that would
make the code much cleaner.  We could assume that one "foo bar in file
baz" line in <tt>"*Edit-Definitions*"</tt> will produce at most one hit
in one buffer (which would make the next paragraph unnecessary).  If
this is really true, and I don't yet believe it, we may be able to get
rid of all the <tt>"back-p"</tt> args that clutter up the code.  -- rgr,
9-Sep-02.]

<p>As a result of this, I am trying to structure the new
<tt>lisp-locate-clisp</tt> implementation such that only one search is
performed, using the best available strategy for the definition type and
whatever parent information the Lisp might cough up.  [The idea just
occurred to me, so the existing patch is probably not nearly so clean.
-- rgr, 9-Sep-02.]

<p>[It would be nice if the various search functions were to return a
regexp instead of actually doing the searching.  Then we could
centralize the search calls, and maybe do a better job of handling
multiple hits per buffer when we thought there should only be one.  --
rgr, 9-Sep-02.]

<p>
<hr>
<a name=further-work>
<h2>Further work</h2>

I've divided this up into things I figure I need to do in the near term,
and other features that would be neat if time and ambition permit.

<h3>Things to do</h3>

These are things that I want to have working before patching into
<tt>ilisp</tt> proper.

<dl>
  <dt> Escaping <tt>elisp</tt> special characters.
  <dd> Right now, if you have a definition name that contains a
       <tt>"?"</tt>, you lose.  But the current implementation also has
       this problem.  [Except for Lisp vertical bars, the immediate
       problem is fixed.  This should eliminate elisp reader errors, but
       there may still be broken uses of <tt>"%S"</tt> lying around.  --
       rgr, 14-Sep-02.]
  <dt> ** Finish code for parent/child relationships.
  <dd> The stuff in the <a href="#static-nesting">"Statically nested
       definitions"</a> section is incompletely implemented.

       <a name = package-dwim>
  <dt> * Package DWIM.
  <dd> It would be nice to search all packages for similar symbols,
       instead of throwing up our hands if we find no symbol, or a
       symbol with no definitions.  -- rgr, 2-Sep-02.  [But this may
       require a protocol extension, unless we want to find and return
       <i>everything</i> that's defined in any package.  -- rgr,
       19-Sep-02.]
  <dt> * Check <tt>lisp-edit-files</tt> functionality.
  <dd> This interface has been damaged in the crossfire; need to test
       and restore functionality.  [probably need to reinstate "any"
       type search.  however, that would most likely require
       generalizing the search, since gluing all possible regexps
       together with <tt>"\\|"</tt> won't work.  -- rgr, 16-Sep-02.]
  <dt> * Bug: CMUCL conditions don't work.
  <dd> E.g. the condition <tt>print-not-readable</tt> can't be found at
       all (no source file recording), and <tt>ilisp</tt> thinks the
       slot accessor <tt>print-not-readable-object</tt> is in
       <tt>code/error.lisp</tt>.  Probably requires CMUCL patchery.
  <dt> * Bug: ACL class slot accessors conflict with classes.
  <dd> In ACL, defining <tt>foo</tt> as a class slot accessor in
       one file and as a class in another file makes the slot accessor
       unfindable.  This is Franz's fault; <i>both</i> are recorded as
       <tt>:type</tt> definitions, and there isn't a damn thing we can
       do in the Lisp to decide which is which.  So this may not be
       fixable.

       <a name = no-sbcl-struct-accessors>
  <dt> *** SBCL structures.
  <dd> I haven't yet figured out how to find the source file of a
       structure in SBCL.  Accessors don't have source information,
       either, so even though I can go from an accessor function to a
       structure name, it doesn't do me any good.  -- rgr, 20-Sep-02.
</dl>

<a name = issues>
<h3>Issues</h3>

These are things that need to be resolved, possibly with changes made,
before this patch can be integrated into <tt>ilisp</tt>.

<a name = lisp-edit-files>
<h4>Issue 1: Possible loss of <tt>lisp-edit-files</tt> fallback</h4>

Recall that the <tt>lisp-edit-files</tt> fallback is only useful when
the Lisp can't say much about the definition of interest, i.e. when
source file recording is off or unimplemented.  I myself never use this
feature, nor the <tt>find-tag</tt> fallback for that matter, because I
only ever use Lisps with source file recording.  (Furthermore, it always
annoyed me that <tt>edit-definitions-lisp</tt> messes up the visitation
order in emacs' <tt>*Buffer&nbsp;List*</tt>, so I always set
<tt>lisp-edit-files</tt> to <tt>nil</tt>.  As it happens, this minor
annoyance is now fixed.)  As a result, I have no experience with this
feature, and not much faith in its usefulness.  Are there any Lisps
anywhere that don't implement source file recording?

<p>Still, there is value added in that a Lisp with no source file
recording (if such a thing exists) could still tell us that <tt>foo</tt>
is a defstruct instead of a function or variable, which helps to narrow
the search over what <tt>find-tag</tt> could provide.  But at this
point, we're still doing simple 

<p>So, if I were to restore the <tt>lisp-edit-files</tt> search, it
would probably be as an explicit use of <tt>search-lisp</tt> to look for
the same pattern as <tt>ilisp-locate-clisp-defn</tt> would, using
<tt>"^(def<i>foo</i>&nbsp;<i>name</i>"</tt> as the ultimate fallback.
This may provide a better user interface for the possibility that we
might get multiple hits as a result of casting our net so much wider.
It also has the further advantage of taking all of the <a
href="#search-logic">"look for multiple occurrences"</a> situations out
of the <tt>M-.</tt> implementation.  But I would not enable it by
default.  It is not helpful to search all Lisp buffers when the user
inadvertently asks to see a Common Lisp function in ACL, for example.

<p>Note that I am discussing only the alternative
<tt>edit-definitions-lisp</tt> usage of <tt>lisp-edit-files</tt>.  Both
<tt>search-lisp</tt> and <tt>replace-lisp</tt> use
<tt>lisp-edit-files</tt>, and both are currently broken to some extent,
but this can be fixed by separating their implementation from that of
<tt>M-.</tt>, with which they now have much less in common.

<a name = packaging>
<h4>Issue 2: Packaging into <tt>"*.lisp"</tt> sources</h4>

[also relates to using PCL/SB-PCL/MOP packages, related "compile once"
philosophy.]

<a name=deferred-features>
<h3>Deferred features</h3>

These are things that won't make it into the initial versions, and may
not make it in at all.  Some may be intractable; for example, some
features of the function-parent extension may require cooperation from
the Lisp implementation.

<dl>
  <dt> Hints
  <dd> It would be useful to have a general mechanism by which a Lisp
       could tell emacs that, for example, it was incapable of
       determining whether a function was a defstruct slot accessor or
       not.  Better still, putting the hint on each returned definition
       to which it might apply, rather than having one general hint that
       describes the Lisp's capabilities, would allow the Lisp to rule
       out such things as (to continue the accessor example) functions
       that do not take exactly one argument.  That way, emacs could
       enable broader search heuristics in such cases.  -- rgr,
       13-Sep-02.

       <p>
  <dt> Reusing the protocol
  <dd> The protocol can (and should) be reused to improve the "hit rate"
       of the <tt>list-callers-lisp</tt> command.  A Zmacs-style
       <tt>List&nbsp;Combined&nbsp;Methods</tt> command could also be
       implemented (though the interface would have to be rather
       different to handle CLOS multimethods).

       <p>As part of that, <tt>list-callers-lisp</tt> should support
       iterating through multiple sets of callers concurrently.  This is
       fairly straighforward to implement with a stack of
       <tt>*Callers-<i>i</i>*</tt> buffers.  (I have code, not part of
       this patch, that does this for <tt>M-x&nbsp;grep</tt> and
       friends.)

       <p>
       <a name = protocol-extensibility>
  <dt> User protocol extensibility.
  <dd> Ideally, applications would be able to use a portable,
       user-extensible "record source file name" mechanism (to echo the
       Lisp Machine <tt>si:record-source-file-name</tt> API call) to
       make their custom definitions findable via <tt>M-.</tt> on all
       available Lisps.  However, this is hard to do without making
       applications depend on <tt>ilisp</tt>.  The best strategy might
       be to release a portable implementation into the public domain,
       which application developers could incorporate into their
       packages in the short term, and Lisp implementors could adopt
       over the longer term.  Eventual ANSI standardization would be
       ideal, but is probably too much to expect . . .

       <p>In the nearer term, Allegro application programmers should be
       able to use the existing extensibility features of
       <tt>excl:source-file</tt> to add their own definition types, and
       <tt>ilisp</tt> should just be able to find them without
       additional help.  In practice, even using the existing ACL
       feature will probably need some extra tweaks.  In particular,
       application definition macros often expand into functions, which
       will probably require a generalization of the function-parent
       feature as well.

       <p>
  <dt> Buffer priority
  <dd> A cool feature of the Zmacs implementation is that it gives
       priority to definitions found in the current buffer, followed by
       definitions in other buffers, followed by definitions in files
       not yet read in.  This could be implemented by a prepass on the
       <tt>ilisp:source-files</tt> result before stuffing it into
       <tt>*Edit-Definitions*</tt>.  Ideally, user hooks would be
       provided to allow the user to control some or all of the sorting
       decisions, but I have no idea what this might look like.

       <p>
       <a name = buffer-mode>
  <dt> Special mode for the <tt>"*Edit-Definitions*"</tt> buffer.
  <dd> It is shameful that <tt>M-.</tt> in this buffer gets you
       <tt>find-tag</tt>, and there is no shorthand for "edit the
       definition where <tt>(point)</tt> is now."  Where possible, this
       mode should be compatible with what <tt>M-x&nbsp;grep</tt> and
       <tt>M-x&nbsp;compile</tt> give you.

       <p>
       <a name = special-cases>
  <dt> Handling special cases.
  <dd> Here are some things that are known to be missing or buggy:
       <ul>
	 <li> <tt>EQL</tt> specializers in CLOS methods.  These are not
	      handled by the Lisp end (which probably breaks), and not
	      recognized properly by the emacs end.
	 <li> Structure constructors and predicates (though constructors
	      at least seem to work in CMUCL).
       </ul>

       <p>
  <dt> Lisp packages.
  <dd> The current treatment of Lisp packages need some cleanup.  The
       Lisp component prints with <tt>*package*</tt> bound to the
       <tt>ilisp</tt> package, so that (unless you are exploring
       <tt>ilisp</tt> code) all non-CL symbols (almost) are printed with
       package prefixes; this allows the user to see their "true names."
       The prefixes are stripped off for searching, and (sometimes)
       replaced by a regexp fragment that matches any package prefix or
       none (see <tt>lisp-optional-package-regexp</tt>).  This "generic"
       package prefix regexp gets around package name and symbol import
       issues, but opens up the possibility of false positives.  The
       most robust thing would be to check back with the Lisp, asking
       "Does this definition really have this name?"  This would also
       handle reader conditionalization, and could detect many cases of
       a definition that had been "commented out" in favor of another in
       the same buffer.

       <p>
  <dt> Support for non-ANSI Lisps.
  <dd> Personally, I don't care a whit for supporting non-ANSI Lisps.
       But many people like the case sensitivity of Allegro, for
       example, so that's probably not a tenable position for the long
       term.  What a pain this is.

       <p>
  <dt> The standard definition type names should be "keyword"
       symbols.
  <dd> They are keywords in Lisp, and so it is silly to pass them around
       as strings in emacs (after stripping off the colon).  It is also
       ambiguous with respect to user-defined definition names.
       Unfortunately, these names are part of the protocol, so this
       raises internal compatibility issues, i.e. with other Lisps that
       don't yet implement the new protocol.  -- rgr, 9-Sep-02.
</dl>

<p>
<hr>
<a name=references>
<h2>References</h2>

<dl>
  <a name=amop>
  <dt> [AMOP]
  <dd> [for intro to concept of "introspection".  -- rgr, 19-Sep-02.]
  <a name=Emacs1979>
  <dt> [Emacs1979]
  <dd> Richard M. Stallman, <a
       href="http://www.gnu.org/software/emacs/emacs-paper.html"><b>Emacs,
       the Customizable, Extensible Display Editor</b></a>, MIT AI Lab,
       1979.  See in particular the <a
       href="http://www.gnu.org/software/emacs/emacs-paper.html#SEC8">
       "Editing Large Programs"</a> section.
  <dd> [EmacsWiki]
  <dt> <a
       href="http://www.emacswiki.org/cgi-bin/wiki.pl?CategoryHistory">
       Emacs history</a> at the <a
       href="http://www.emacswiki.org/">Emacs Wiki</a> site.
  <dt> [???]
  <dd> [Stallman biography.  -- rgr, 13-Sep-02.]
</dl>

<p>
<hr>
<address><a href="mailto:rogers@rgrjr.dyndns.org">Bob Rogers
	<tt>&lt;rogers@rgrjr.dyndns.org&gt;</tt></a></address>
<!-- hhmts start -->
Last modified: Mon Sep 23 21:18:24 EDT 2002
<!-- hhmts end -->
</body> </html>
