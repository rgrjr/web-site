<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>ICanCAD part internals</title>
</head>

<body bgcolor=white>
<h2>ICanCAD part internals</h2>

<p><a href="/"><tt>Home</tt></a> : <a href="index.html">ICanCAD</a> :
<a href="internals.html">Internals</a> : Part internals
<hr>

<p>
<h3>Table of contents</h3>

<!-- hhmtoc start -->
<ol>
  <li> ICanCAD part internals
       <ol>
	 <li> Table of contents
	 <li> <a href="#part">Parts in general</a>
	      <ol>
		<li> <a href="#part-classes">Part classes</a>
		<li> <a href="#selection">Part selection</a>
		<li> <a href="#stretch">Part stretching</a>
		     <ol>
		       <li> Stretching protocol
		       <li> Part stretching API
		       <li> Part stretching notes
		     </ol>
		<li> <a href="#part-names">Part names</a>
	      </ol>
	 <li> <a href="#specific">Parts in particular</a>
	      <ol>
		<li> <a href="#uses">Uses</a>
		<li> <a href="#text-parts">Text parts</a>
		     <ol>
		       <li> <a href="#use-labels">The <tt>label-def</tt> and <tt>basic-label-use</tt> classes</a>
		     </ol>
		<li> <a href="#line-parts">Line parts</a>
		<li> <a href="#rect-parts">Rectangle parts</a>
	      </ol>
	 <li> <a href="#import-ps">Importing picture graphics</a>
       </ol>
</ol>
<!-- hhmtoc end -->

<a name = part>
<h3>Parts in general</h3>

<a name = part-classes>
<h4>Part classes</h4>

Here is a summary of the top of the part class hierarchy:
<pre>
basic-part
   part-with-subparts
      basic-use ...
   basic-text
      text-part ...
      labelled-point ...
   fillable-part
      part-with-vertices
	 basic-line ...
         basic-rectangle ...
	 arc
   basic-dot-part ...
   schematic-link
</pre>
This gives rise to five basic categories of symbolic parts, and three of
schematic parts.  The schematic parts are covered in <a
href="wiring.html">"ICanCAD Schematic Wiring Implementation"</a>, and
will not be discussed in any detail on this page.

<p>Each part class that is actually instantiated has a unique "part
kind", the name of which (a symbol) is returned by <tt>part-kind</tt>,
e.g. <tt>rectangle</tt> for <tt>basic-rectangle</tt> instances, and
<tt>text</tt> for <tt>text-part</tt> instances.  The part kind reflects
the specific nature of the part, and is how "Add Part" and related
commands present the categories of available parts to the user.  Part
kinds are also used by the load/save code to decide what class of thing
to instantiate.

<p>The basic symbolic categories are shown below, together with the
names of the associated instantiable classes and their part kinds in
parentheses:
<ol>
  <li> <a href="#text-parts">Text parts</a> (<tt>text-part</tt> of kind
       <tt>text</tt> is for ordinary text, <tt>pin</tt> and
       <tt>net-label</tt> are for text associated with an independent
       location, and <a href="#use-labels"><tt>label-def</tt> and
       <tt>basic-label-use</tt></a> (of kinds <tt>label-def</tt> and
       <tt>label-use</tt>, respectively) are for defining and displaying
       use labels).
  <li> <a href="#line-parts">Lines</a> (<tt>basic-line</tt>, which
       implements polygons as a special case, is a <tt>line</tt> part,
       and <tt>arrow</tt> is an <tt>arrow</tt>).  [but there is still a
       <tt>polygon</tt> part-kind as far as the part-adding interface is
       concerned.  -- rgr, 20-Nov-01.]
  <li> Arcs (<tt>arc</tt> includes circles as a special case, so
       these are both <tt>arc</tt> parts).  [but there is still a
       <tt>circle</tt> part-kind as far as the part-adding interface is
       concerned.  -- rgr, 20-Nov-01.]
  <li> <a href="#rect-parts">Rectangles</a> (a <tt>basic-rectangle</tt>
       is of kind <tt>rectangle</tt>, and an <tt>oblong</tt> is of kind
       <tt>oblong</tt>).
  <li> <a href="#uses">Uses</a> (a <tt>schematic-use</tt> is a
       <tt>use</tt> part, while a <tt>symbolic-use</tt> is
       <tt>symbolic-use</tt> part; the distinction is necessary so that
       both kinds of uses can be saved in schematic defs).
</ol>
All instantiable part classes in each category will look more or less
the same to the user; we therefore assume that the user would like to
have all parts within a given category behave similarly, to the greatest
extent possible.  So, for instance, all rectangle-ish parts should
stretch in more or less the same way, etc.

<p>[Note that there is some fudging going on here.  The part-adding
interface presents lines and polygons as distinct objects (albeit easily
convertible) even though they are both implemented as
<tt>basic-line</tt> instances, and similarly for arcs and circles.  For
this purpose, there are short-lived <tt>polygon</tt> and <tt>circle</tt>
"kinds."  [Though the <tt>part-kind</tt> methods could be made to return
these when appropriate.  This might be better for UI reasons, and make
the distinction in the disk save format.]  -- rgr, 20-Nov-01.]

<p>For completeness, here is a subset of the class hierarchy graph with
the schematic part categories filled in:
<pre>
basic-part
   basic-text
      text-part ...
      labelled-point
         port-dot
         net-label
      ...
   basic-dot-part
      scratch-dot
      bristle
   schematic-link
   ...
</pre>
[This omits labels, though.  -- rgr, 31-Jan-02.]

<a name = selection>
<h4>Part selection</h4>

[New Janus stored selected parts explicitly as a list, accessed by the
<tt>selected-parts</tt> generic (or equivalent).  ICanCAD presently uses
an explicit slot in the part, accessed by <tt>part-selected?</tt>.
Unfortunately, this means that <tt>selected-parts</tt> must visit all
parts to cons up the set on the fly, and the <tt>selected-parts</tt>
operation is used fairly frequently.  Better would be to use both,
maintaining the per-part boolean to decide when and how to update the
list.  -- rgr, 28-Oct-01.]

<a name = stretch>
<h4>Part stretching</h4>

<p>(New Janus did stretching better (i.e. in a more general way) than
Rel-Janus, but it still had a lot of kludges and special cases.  So far,
ICanCAD seems to be better still, but I don't really have a clear
picture of what the user interface should be.  I've kept the current UI
simple, but what I've implemented internally may not be the best thing
in the long run.  -- rgr, 27-Oct-01.)

<p>Stretching a part means moving its vertices around by means of
handles.  This is accomplished by using a vector of vertex handle
objects, one for each vertex, each which can be selected and stretched
without modifying the part; when the user places the selected vertex (or
vertices), the <tt>stretch-part</tt> generic installs the vertices in
order to make the change.  Installation is done either by setting the
<tt>vertices</tt> property, or by <tt>transform-part</tt> for parts with
transforms.  Going through the property or transform operations is what
makes stretching undoable, effectively for free.

<p>All parts are stretchable, in the following ways:
<ol>
  <li> Uses and text parts have a single vertex, and stretch trivially
       by translating the part.  It is an error to attempt to change
       <tt>part-vertices</tt> any other way.  (Some day it may be
       possible to move any labels or bristles that decorate the part by
       stretching, but we're punting that for now.)
  <li> Lines/polygons/arrows stretch in the obvious way, by setting the
       <tt>vertices</tt> property of the part.  These are the only kinds
       of parts to which you can add a vertex.  Vertices can also be
       deleted by making them redundant (i.e. stacking them).
  <li> Arcs and circles are stretched by moving one of their three
       defining vertices.
  <li> Rectangles are something of a special case; they have eight
       handles (four corners and four edges) but only two independent
       vertices.  Consequently, we construct "proxy" handles to stand in
       for the edges and the other two vertices.  On the other hand, we
       don't have to worry about preserving orthogonality, as that comes
       for free.
  <li> Schematic dots behave as single vertices, though stretching is
       always propagated through connected links.
  <li> Schematic links behave as if they were polygon segments by
       selecting both connected dots identically.
  <li> Schematic net labels and pins are dots with text; the dot always
       drags the text along, but the text never drags the dot.
</ol>
Note that although all parts support <tt>part-vertices</tt>, not all
parts define the <tt>vertices</tt> property.  [Currently,
<tt>schematic-link</tt> is the only part that doesn't support the
<tt>vertices</tt> property; this should probably be fixed.  -- rgr,
31-Jan-02.]  For purposes of stretching, this property may also be
settable on these parts, but the new value must always have the right
number of vertices (e.g. exactly three in the case of arcs, and two in
the case of rectangles).

<p>Schematic parts have additional requirements for stretching,
described in more detail in the <a
href="wiring.html#wiring-stretch">"Stretching wiring parts"</a> section.
These are basically related to the fact that stretching a wire can
affect the shape or location of neighboring parts.  Wires always do
orthogonality propagation, which goes through connected parts.  This
requires protocol features to hide the extra work that must be done for
schematics.

<h5>Stretching protocol</h5>

All stretch commands are variations on the following theme:
<ol>
  <li> Select one or more parts to be stretched.
  <li> Within selected parts, select one or more handles to be stretched
       in one or both directions.  If <tt>*stretch-orthogonally-p*</tt>
       is true, adjacent vertices may also get selected in order to
       preserve the orientation of vertical or horizontal segments.
  <li> Allow the user to specify a new location for the stretched
       vertices, using <tt>stretch-part-handles</tt> to stretch the
       parts temporarily, and then <tt>highlight-thing</tt> to highlight
       the stretched parts.
  <li> When the user places, perform the actual stretching.  Only in
       this step are any parts actually modified for database purposes.
  <li> Reset all handles (clear their selection state, update the
       unstretched location to be the new stretched location).
</ol>

<p>Handle methods for basic queries:

<dl>
  <dt> <b>handle-type</b> <i>(handle)</i>
  <dd> returns one of <tt>:segment</tt> or <tt>:vertex</tt>.
  <dt> <b>handle-part</b> <i>(handle)</i>
  <dd> returns the related part.
  <dt> <b>handle-offset</b> <i>(handle)</i>
  <dd> returns the offset between the stretched location and the
       unstretched location as two values.  Only actually used by
       <tt>has-transform-mixin</tt> stretching.  [this limitation may no
       longer be true.  -- rgr, 31-Jan-02.]
  <dt> <b>pt-x</b> <i>(handle)</i>
  <dt> <b>pt-y</b> <i>(handle)</i>
  <dt> <b>pt-point</b> <i>(handle)</i>
  <dd> returns the appropriate value for the stretched location.  Only
       expected of vertex handles.
</dl>

Handle selection methods:

<dl>
  <dt> <b>highlight-selected-handles</b> <i>(handle window)</i>
  <dd> shows stretch directions.  [not used at present; we'd need a
       stretching selection mode for this to be required.  -- rgr,
       1-Nov-01.]
  <dt> <b>point-select-handle</b> <i>(handle user-x user-y)</i>
  <dd> selection query.  [not actually used at present; see the part
       method code.  -- rgr, 30-Oct-01.]
  <dt> <b>reset-handle-stretch-state</b> <i>(handle)</i>
  <dd> reset selection and position.
  <dt> <b>select-handle</b> <i>(handle window operator
       stretch-direction)</i>
  <dd> change the selection state of the handle.  This is the main
       entrypoint for GUI code wishing to affect handle selection state;
       the other entrypoint is <tt>reset-handle-stretch-state</tt>.  The
       <tt>operator</tt> parameter must be a function, and is normally
       one of <tt>handle-add</tt> for selection, or
       <tt>handle-subtract</tt> for deselection.  The
       <tt>stretch-direction</tt> value must be one of
       <ul>
	 <li> <tt>:x-only</tt> to alter the handle's horizontal
	      stretchability;
	 <li> <tt>:y-only</tt> to alter the handle's vertical
	      stretchability; or
	 <li> <tt>t</tt> to alter both directions.
       </ul>
       (<tt>nil</tt> is also legal, but would be a noop.)  The
       <tt>window</tt> parameter must currently be <tt>nil</tt>.
  <dt> <b>handle-maybe-propagate-selection</b> <i>(from-handle to-handle
       window operator delta-mask)</i>
  <dd> for preserving orthogonality, called from the main
       <tt>propagate-handle-selection</tt> method.
</dl>

Handle stretching/updating methods:

<dl>
  <dt> <b>highlight-thing</b> <i>(handle)</i>
  <dd> used for handle mouse-over
       highlighting.
  <dt> <b>stretch-handle-temporarily</b> <i>(handle)</i>
  <dd> used by stretch
       highlighting.
  <dt> <b>stretch-handle-permanently</b> <i>(handle)</i>
  <dd> used by the
       <tt>stretch-part</tt> method after doing
       <tt>stretch-handle-temporarily</tt> first.
  <dt> <b>update-handle</b> <i>(handle)</i>
  <dd> used to update a handle after other
       vertex-affecting operations (e.g. <tt>transform-part</tt>).
</dl>

Part query methods:

<dl>
  <dt> <b>part-vertices</b> <i>(part)</i>
  <dd> required for handle definition.  Even
       parts that don't support setting vertices must return at least
       one vertex.  (The default <tt>basic-part</tt> method takes care
       of that by defining a single vertex in the bbox center.)
  <dt> <b>part-handles</b> <i>(part)</i>
  <dd> returns a vector of handle objects, created from the part's
       vertices.
  <dt> <b>map-part-handles</b> <i>()</i>
  <dd> applies the continuation to each of the part's handle objects.
  <dt> <b>map-part-handle-segments</b> <i>()</i>
  <dd> applies the continuation to each adjacent pair of the part's
       handle objects and the 0-based index of the first of the two
       handles.
  <dt> <b>part-stretchy?</b> <i>(part)</i>
  <dd> returns true iff the part has at least one selected handle.
</dl>

Part methods:

<p>[May want to have an explicit <tt>highlight-stretched-part</tt>
method, instead of making the usual mouse-over code do the stretch.  A
default method that used <tt>highlight-thing</tt> would make the
transition easy.  -- rgr, 30-Oct-01.]

<dl>
  <dt> <b>stretch-part-handles</b> <i>()</i>
  <dd> temporarily update all handles
       to the stretched position.
  <dt> <b>highlight-thing</b> <i>()</i>
  <dd> shows the outline of the part in its
       stretched position.  Note that this method is also used for
       normal mouse-over highlighting when not stretching; see <a
       href="#stretch-before-highlight">the note below</a> for how this
       works.
  <dt> <b>stretch-part</b> <i>()</i>
  <dd> execute stretch op by setting a property
       or transforming the part.
  <dt> <b>point-select-handle</b> <i>()</i>
  <dd> find best handle within part.
  <dt> <b>propagate-handle-selection</b> <i>()</i>
  <dd> for preserving orthogonality.
  <dt> <b>reset-part-handles</b> <i>()</i>
  <dd> call
       <tt>reset-handle-stretch-state</tt> on all of the part's handles.
  <dt> <b>update-handles</b> <i>()</i>
  <dd> used to update a part's handles after
       other vertex-affecting operations (e.g. transform).
</dl>

<h5>Part stretching API</h5>

[Such as it is.  -- rgr, 31-Jan-02.]

<p>[need more description.  -- rgr, 31-Jan-02.]

<dl>
  <a name = with-part-stretching>
  <dt> <b>with-part-stretching</b> <i>((parts def selection-form
       &amp;key initial-parts) &amp;body body)</i>
  <dd> Arrange for stretching of some of <tt>def</tt>'s parts.  The
       operation must be split into handle selection and stretching;
       <tt>selection-form</tt> must only do handle selection, and the
       <tt>body</tt> forms must only do stretching without affecting
       handle selection (except possibly to deselect or reset).
       <tt>parts</tt> contains all parts that are
       <tt>part-stretchy?</tt>; it is bound after selection, and
       therefore available to the <tt>body</tt> forms (but not
       <tt>selection-form</tt>).  The <tt>body</tt> forms are not
       evaluated if <tt>selection-form</tt> turns out not to have
       selected any handles.  The selection state of handles within the
       def is always guaranteed to be reset on exit, even for abnormal
       exits.  See below for a description of the <tt>initial-parts</tt>
       parameter.
  <dt> <b>stretch-def-parts-internal</b> <i>(def selection-continuation
       body-continuation &amp;key initial-parts)</i>
  <dd> Implementation of the <tt>with-part-stretching</tt> macro:  Use
       <tt>selection-continuation</tt> and <tt>body-continuation</tt> to
       perform stretching within <tt>def</tt>, taking care of
       def-related bookkeeping and cleanup.  If <tt>initial-parts</tt>
       is non-nil, the caller promises that only handles on these parts
       will be selected, so if the def knows that no other parts could
       be stretchy, it may pass this list directly to the
       <tt>body-continuation</tt> as an optimization.  The <a
       href="wiring.html#schematic-stretch-reconnect">
       <tt>schematic-def</tt> method</a> needs to be more elaborate,
       because it may need to do <a href="wiring.html#reconnection">
       wiring reconnection</a>.
  <dt> <b>stretchy-parts</b> <i>(def)</i>
  <dd> Returns a list of all parts within the def that are
       <tt>part-stretchy?</tt>.
</dl>

<h5>Part stretching notes</h5>

<p><b>Part methods for <tt>highlight-selected-part</tt> must be careful
to use <tt>handle-orig-x</tt> and <tt>handle-orig-y</tt></b> if they
need to refer to handle locations.  Otherwise, when stretching a
selected part (the usual case), unhighlighting the selection before
undrawing the original part may unhighlight in the wrong place, leaving
garbage on the screen.

<p><b>Handle selection.</b> <tt>:vertex</tt> and <tt>:segment</tt>
handles really ought to be sought independently for presentation
purposes.  In other words, rather than have <tt>find-closest-handle</tt>
return the closest of either kind, we should first look for a vertex
handle, and then for a segment handle, in order to make make one of each
kind (if available) visible to the translator selection machinery.  As
it is now, the code will fail to offer a segment operation if a vertex
happens to be nearer the mouse, even if a segment-only operation is the
only thing available on the chord.  [It was this way for
<tt>handle-to-add-vertex</tt>, but now that this can deal with vertices
as well has segments, this selection glitch is not such a problem.  --
rgr, 20-Nov-01.]

<a name = stretch-before-highlight>
<p><b>Stretching, highlighting, and schematic wires.</b> Note that the
handle's stretched location is always initialized to its original
location.  This is what allows mouse-over and stretching highlighting to
be combined; both are performed by <tt>highlight-thing</tt> methods.  To
highlight (e.g.) stretched wiring in its mouse-following location, one
must first map over all parts to stretch by the specified (dx,dy), and
then make a second pass to do the highlighting.  Two passes are
necessary to ensure that all stretched dot-locations are correct before
any links are drawn.

<a name = part-names>
<h4>Part names</h4>

It seems to me these should be symbols, since that is more natural for
Lisp.  But that gets into case issues; Martin likes mixed-case use
names.  Still thinking about this one.

<a name = specific>
<h3>Parts in particular</h3>

<a name = uses>
<h4>Uses</h4>

Conceptually, uses belong entirely to their parents, and not at all to
their children or icons.  No direct reference is made from the use to
the child or icon; instead, the child slot contains a def-name, which
refers to the use through its cached-def slot.  Similarly, the def name
keeps track of child uses, so that the child def does not need any
references to its uses.

<p>Note that it is not possible to change the child or icon of a use
once it has been created; this restriction greatly simplifies updating
of the parent's parent-uses slot.  [This may not be valid; we certainly
want to permit changing an icon on an existing use.  -- rgr, 16-May-01.]
In any case, as long as this restriction holds, we should apply GUI
magic to make it look otherwise to the user.  [We may want to relax this
for the special case of when the child is renamed . . .  -- rgr,
16-May-01.]

<p>The <tt>parent-uses</tt> slot has been moved from the def itself to
the def name (as of 16-May-01).  This should make updating easier when a
child def is deleted, reverted, or renamed.

<a name = text-parts>
<h4>Text parts</h4>

The <tt>basic-text</tt> class supports the justification, transform, and
text size attributes of parts that display as text strings (where
transform and text size are supported by using has-transform-mixin with
a scaling transform).  There are then three classes that build on
basic-text, differing in how the displayed string is defined:

<ul>
  <li> text-part has a text-string slot (read by part-text-string) that
       is defined as the text property of the part; the string is user
       defined, and does not depend on anything else.  These are
       normally used for annotation by the user, including for pins and
       net labels (since their displayed text string is a defining
       property).
  <li> cached-text-part has a cached-text-string slot (also read by
       part-text-string) that is also available as the text property of
       the part, but is not settable.  Instead, the string is defined
       indirectly, and recomputed via the compute-text-string generic
       when the defining property changes.  These are used for icon
       label-def parts, where the displayed string is defined by a Lisp
       expression.
  <li> basic-label-use does not have a single well-defined text string
       at all.  Its string depends on the context, so it can be drawn on
       a given window (where context is always defined), but isn't
       simply available as a property.  basic-label-use's aren't
       intended to be created directly by users; they are created from
       icon label-def parts when the icon is used.
</ul>

<a name = use-labels>
<h5>The <tt>label-def</tt> and <tt>basic-label-use</tt> classes</h5>

These two classes implement use labels.  When a use with a given
schematic icon is instantiated, a basic-label-use instance is created
for each label-def part in the icon, and is added as a subpart to the
use.  Once created, the basic-label-use is completely independent of its
generating label-def part; users must do <a
href="commands.html#com-update-uses">"Update Uses"</a> in the parent
(which also updates changed bristles).

<p>[A basic-label-use is unique in that it needs external information
(i.e. property values) in order to decide how to draw itself.  As a
result, it could potentially need to redraw itself if a property changes
somewhere else.  Even its bounding box may need to change to accomodate
its new contents.  -- rgr, 21-Jun-01.]

<a name = line-parts>
<h4>Line parts</h4>

Arcs (and now rectangles) are lumped with lines in order to allow some
common behavior to be shared between them.  For instance, the methods
for <tt>closed-figure?</tt>, <tt>highlight-selected-part</tt>,
<tt>initialize-instance</tt> (the vertex-initializing daemon),
<tt>part-vertices</tt>, <tt>(setf&nbsp;part-vertices)</tt>,
<tt>print-object</tt>, and <tt>transform-part</tt> that used to be
defined on <tt>basic-line</tt> are now shared with the <tt>arc</tt> and
<tt>basic-rectangle</tt> classes.

<a name = rect-parts>
<h4>Rectangle parts</h4>

Rectangles are also built on the <tt>part-with-vertices</tt>.  [This
means they use <tt>cached-bounding-box-mixin</tt>, which is a little
strange, though more consistent with other part classes.  -- rgr,
5-Nov-01.]

<a name = import-ps>
<h3>Importing picture graphics</h3>

It would be nice to be able to import picture graphics (i.e. line
drawings) in some reasonable way.  It might be possible to convert
PostScript into primitive lines, polygons, and text in a way that
ICanCAD could deal with.  (PostScript is a hairy language, but there
might be a relatively easy way to define a special back-end for the
Ghostscript interpreter that spits out ICanCAD save format directly!)
That way, users could build an initial library for whatever other CAD
system they were using by "printing" a huge page with all of their icons
on it, importing that as PostScript into ICanCAD, and then cutting it up
into individual icon defs in the ICanCAD icon editor.

<p>
<hr>
<address><a href="mailto:rogers@rgrjr.dyndns.org">Bob Rogers
	<tt>&lt;rogers@rgrjr.dyndns.org&gt;</tt></a></address>
<!-- hhmts start -->
Last modified: Wed May  1 13:01:30 EDT 2002
<!-- hhmts end -->
</body> </html>
