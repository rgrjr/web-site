<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>ICanCAD: Miscellaneous notes</title>
</head>

<body bgcolor=white>
<h2>Miscellaneous notes</h2>

<p><a href="/"><tt>Home</tt></a> : <a href="index.html">ICanCAD</a> :
<a href="internals.html">Internals</a> : Miscellaneous
<hr>

<p>[this is more or less a scratch area, for documenting internal things
that don't obviously have a place of their own.  -- rgr, 29-Mar-01.]

<p>[alternative bbox decaching for (e.g.) the basic-label-use class.
caching of "medium-weight" push/pop contexts.  -- rgr, 25-Jun-01.]

<h3>Table of contents</h3>

<!-- hhmtoc start -->
<ol>
  <li> Miscellaneous notes
       <ol>
	 <li> Table of contents
	 <li> <a href="#editing">Editing notes</a>
	      <ol>
		<li> General editing notes
	      </ol>
	 <li> <a href="#defs">Defs</a>
	      <ol>
		<li> <a href="#timestamps">Timestamp daemons</a>
		<li> <a href="#save-format">Def save format</a>
		<li> <a href="#selected-parts">Keeping track of selected parts</a>
		<li> <a href="#janus-icon-conversion">Janus icon conversion</a>
		<li> <a href="#primitive">Primitive "devices" in ICanCAD</a>
		<li> <a href="#revert-def">The <tt>revert-def</tt> operation</a>
		<li> <a href="#part-parent">Part parents</a>
	      </ol>
	 <li> <a href="#issues">Random issues</a>
	      <ol>
		<li> <a href="#inline-user-doc">Inline command documentation</a>
		<li> <a href="#inline-internal-doc">Inline HTML documentation of internals</a>
	      </ol>
       </ol>
</ol>
<!-- hhmtoc end -->

<p>
<hr>
<a name = editing>
<h3>Editing notes</h3>

<h4>General editing notes</h4>

These apply to the ancient version of Claris Draw (from the Claris Works
bundled with my wife's 1995 Macintosh Performa) that I am studying for
clues to how the world expects a "draw" application to work.  In case
you hadn't guessed, I don't have much of a need for these myself.

<ul>
  <li> Dragging a selected corner seems to transform all vertices in the
       same way that the corners are transformed.  If multiple parts are
       selected, all vertices of all parts have the same transform
       applied.  Transform will in general scale axes independently, but
       cannot rotate.
  <li> What to do about the back-to-front drawing CLIM is giving me?  It
       might look good, but supporting it fully might be a pain in the
       butt.  [True, but we really ought to do this right.  And now I'm
       the one giving me back-to-front drawing, but unless we want to
       dig into the gcontext level (which wouldn't work on Windows
       anyway), CLIM still only supports IOR drawing in color.  -- rgr,
       21-Jan-02.]
  <li> Toolbar part adding commands are one-shot if you single-click
       them, modal if you double-click.  [That would be nice, but CLIM
       doesn't give us the menu click.  -- rgr, 21-Jan-02.]
</ul>

<p>
<hr>
<a name = defs>
<h3>Defs</h3>

<a name = timestamps>
<h4>Timestamp daemons</h4>

[I am wrestling with the issue of providing a way to put a hook on a def
that will fire when the def gets modified in a certain way.  The elegant
thing to do would be to implement a general mechanism on the
<tt>has-timestamps-mixin</tt> class that solves it once and for all.
The simple thing for the short term would be to define daemon methods
that implement what I need for the time being.  Stay tuned.  -- rgr,
13-Nov-01.]

<p>[See the <a href="properties.html#timestamp-ops">"Timestamp
operations"</a> section for how it works now.]

<a name = save-format>
<h4>Def save format</h4>

"PBIN" stands for "Portable Binary," and was originally developed at
Analog Devices for the Janus CAD system.  ICanCAD includes an
independent implementation that was originally written for the sake of
reading and writing defs in Janus format, but now uses "PBIN" format for
reading and writing defs in their "native" format (though the native
save format is still changing).  This is because there are a number of
advantages to using a binary format.
<ol>
  <li> A PBIN file is more compact than equivalent text.
  <li> It is generally faster to read and write binary files in Lisp, as
       it skips the powerful-but-slow Lisp read/print implementation.
  <li> Finally, a binary format can be defined in such a way as to make
       it robust and unambiguous, even in a heterogeneous file-sharing
       environment where text line-end conventions may vary.
</ol>
Although it is not possible to examine and repair the disk version of a
def directly with an ordinary text editor, ICanCAD provides the <a
href="commands.html#com-dump-pbin">"Dump PBIN"</a> and <a
href="commands.html#com-load-pbin">"Load PBIN"</a> commands as debugging
aids.

<p>[document something of the internal format?  -- rgr, 5-Feb-02.]

<p>[Janus only recognizes PBIN version 1, which uses the Lisp Machine
character set, though defs that have LM characters that are not from the
ASCII subset are probably pretty rare.  In the future, we might have to
create a PBIN version 2 if we want to respecify the character format in
terms of Unicode.  In the mean time, we are careful to use only
characters in the range #x20 (ASCII space) to #x7E (ASCII "~"),
inclusive, which incorporates all ASCII graphic characters.  -- rgr,
5-Feb-02.]

<p>[Note that supporting both text format and a binary format files that
use the same set of file extensions may be tricky wrt line end
conventions and non-transparent file servers.  -- rgr, 19-Nov-01.]

<a name = selected-parts>
<h4>Keeping track of selected parts</h4>

The basic selected set operations are:
<ul>
  <li> Given a part, query or change its selection state.  This is done
       via the <tt>part-selected?</tt> and
       <tt>(setf&nbsp;part-selected?)</tt> generics.
  <li> Given a def, find or change the set of selected parts.  This is
       done via the <tt>selected-parts</tt> and
       <tt>(setf&nbsp;selected-parts)</tt> generics.
  <li> Given a def, iterate over the selected parts.  [There are no
       primitives for this; presently, one does <tt>mapping-parts</tt>
       and checks for <tt>part-selected?</tt> on each one.  -- rgr,
       26-Jan-02.]
</ul>

Since operating on and changing the set of selected parts is frequent,
we would like to avoid <i>O(N)</i> time operations to the extent
possible.  The possible implementations (that I can think of) are:
<ul>
  <li> <b>Keep an explicit list of selected parts.</b> Since it is
       always immediately available, returning the set is <i>O(1)</i>.
       Most other operations have <i>O(k)</i> time complexity, where
       <i>k</i> is the number of selected parts.  Changing the set from
       one with <i>k<sub>1</sub></i> members to one with
       <i>k<sub>2</sub></i> members is
       <i>O(k<sub>1</sub>k<sub>2</sub>)</i>, since we must compute set
       differences in order to maintain the highlighting.
  <li> <b>Keep a selection flag on each part.</b> In this case, querying
       or setting the part state is <i>O(1)</i>, but anything that
       involves the whole set is back to <i>O(N)</i>.  Changing the set
       to one with <i>k<sub>2</sub></i> members is
       <i>O(N)+O(k<sub>1</sub>k<sub>2</sub>)</i>, since we must shut off
       highlighting for all parts not in the new set.  (We must iterate
       through each of <i>N</i> parts, and for the <i>k<sub>1</sub></i>
       members of the old set, we perform an <i>O(k<sub>2</sub>)</i>
       membership test.)
  <li> <b>Keep both a part flag and an explicit set.</b> In this case,
       querying the part state and asking for the set are both
       <i>O(1)</i>; the obvious data structures are optimal for each.
       Updating the part state is <i>O(1)</i> to select (because we
       don't have to test for list membership) though still <i>O(k)</i>
       to unselect (because we have to take it out of the list).
       Changing the set from one with <i>k<sub>1</sub></i> members to
       one with <i>k<sub>2</sub></i> members is still
       <i>O(k<sub>1</sub>k<sub>2</sub>)</i>, since we must compute at
       least the first set minus the second set in order to maintain the
       highlighting.
</ul>

<p>Having tried both the first and second approaches, I'm ready to give
the third one a shot.

<p>Obviously, all operations must update both data structures.  Here's
the protocol, and what needs to happen:
<dl>
  <dt> <b>part-selected?</b> <i>part</i>
  <dd> Returns the value of the part's selection boolean (stored on the
       part).
  <dt> <b>(setf part-selected?)</b> <i>new-value part</i>
  <dd> In addition to updating the boolean, we must do one of the
       following:
       <ol>
	 <li> If the part was selected and is now being deselected,
	      unhighlight and take the part out of the selected set
	      list.
	 <li> If the part was not selected and is now being selected,
	      highlight and push the part onto the selected set list.
	 <li> Otherwise, do nothing.
       </ol>
  <dt> <b>selected-parts</b> <i>has-parts-mixin</i>
  <dd> Returns the selection set as a list (stored on the def).
  <dt> <b>(setf&nbsp;selected-parts)</b> <i>new-set has-parts-mixin</i>
  <dd> <ol>
	 <li> For each part in the old set that does not appear in the
	      new set, clear its selection flag.
	 <li> For each part in the new set, set its selection flag.
	      (This will be a noop if it is already selected.)
	 <li> Install the new set.
       </ol>
  <dt> <b>map-selected-parts</b> <i>has-parts-mixin continuation</i>
  <dd> Just do <tt>(mapc selected-set continuation)</tt>.
  <dt> <b>selected-part-count</b> <i>has-parts-mixin</i>
  <dd> Returns a count of selected parts.  This is provided as a
       separate operation because it is used frequently (or should be),
       and the optimal code for the cached set implementation is
       <tt>(length&nbsp;selected-set)</tt>, but the optimal thing for
       the uncached implementation is <tt>(count-if #'part-selected?
       parts)</tt>.
</dl>

<p>Really, if there is a means to mark parts, then installing a new set
in either of the explicit-set approaches could be changed to
<i>O(k<sub>1</sub>+k<sub>2</sub>)</i> time complexity by the following
algorithm:
<ol>
  <li> Iterate through all members of the new selection set, selecting
       and highlighting each part if not already selected, and marking
       it with a unique value that indicates that it belongs to the new
       set.
  <li> Iterate through all members of the old selection set, unselecting
       and unhighlighting each part that is not appropriately marked.
</ol>
Similarly, the flag-only approach could be done in
<i>O(N+k<sub>2</sub>)</i> time by iterating through all parts in step 2.
However, I doubt this is worth it, as one or both of the
<i>k<sub>i</sub></i> are almost always pretty small.

<a name = janus-icon-conversion>
<h4>Janus icon conversion</h4>

<p>The <a href="schematic.html#janus-icons">differences in icon
representation</a> between ICanCAD and Janus pose something of a problem
when attempting to do the conversion reversibly.  There are several
possibilities with which the code must contend:
<blockquote>
<dl>
  <dt> Saving a <tt>".sch"</tt> def with unmodified icons.
  <dd> In this case, it is desirable to regenerate the original
       deficonshape form for the schematic, and have it refer to the
       original Janus shape def.  This is done by using the icon's
       <tt>shape-def-name</tt> property, if present, and regenerating
       the deficonshape form as it was in the original schematic.
  <dt> Saving a <tt>".sch"</tt> with a modified <tt>".shape-def"</tt>
       icon.
  <dd> There are two subsidiary cases:
       <ol>
	 <li> If the shape def was renamed, then it can be saved without
	      fear of causing problems for any other Janus schematic.
	      (This is why we were careful to ensure that <a
	      href="schematic.html#janus-icon-rename"> there was no
	      existing shape def of that name</a> when converting the
	      containing schematic.)
	 <li> If the shape def was not renamed, then it did not need to
	      have any of its pins mangled, so as long as the user did
	      not modify any pins, the shape def will continue to be
	      consistent will all schematics.  (If the user did modify
	      the pins, then that's another story, but at least it's no
	      worse than modifying a shared icon solely within Janus --
	      or within ICanCAD, for that matter.)
       </ol>
       Either way, we can save the <tt>".shape-def"</tt> icon normally
       its presently location, as long as we break the association with
       the original shape def by removing the <tt>shape-def-name</tt>
       property, so as not to confuse any later schematic saves.
  <dt> Saving a modified <tt>".shape-def"</tt> icon.
  <dd> If this was a "copied" shape def, and there is still a link to
       the original shape def, then this link needs to be broken, in
       order to make the copy operation effectively permanent.  So as a
       result, the "owning" schematic must be modified in order to force
       the save of an updated deficonshape form.  If we can't find the
       owning schematic (because the property is missing, or doesn't
       point anywhere), then presumably this shape def was not the
       product of an in-place icon conversion, so saving it in Janus
       format in the original location should be OK.
  <dt> Renaming a <tt>".shape-def"</tt> icon.
  <dd> This modifies the icon, and is therefore no different from the
       previous case.
</dl>
</blockquote>
Perhaps remarkably, all of the cases in which a <tt>".shape-def"</tt>
icon is saved require that the <tt>shape-def-name</tt> property is
removed in order to break the association with the original shape def,
and (perhaps) that the schematic be re-saved in order to reflect this.

<p>A number of properties are set on <tt>".sch"</tt> and
<tt>".shape-def"</tt> defs in order to facilitate the repackaging of
ICanCAD icons into Janus shape defs:
<dl>
  <dt> <b>shape-def-name</b> <i>(of a shape def)</i>
  <dd> For a schematic that was copied during in-place conversion, this
       property stores the original Janus shape def name, as a string
       (in Janus syntax, if there's a difference).  If bound, it
       indicates that the shape def was in fact copied during in-place
       conversion.  The <tt>shape-def-name</tt> property is removed in
       order to break the association with the original shape def.
  <dt> <b>owning-schematic</b> <i>(of a shape def)</i>
  <dd> The name of the schematic for which it was converted, stored as a
       string (in ICanCAD syntax).  This is only used to allow a
       <tt>".shape-def"</tt> icon to find its schematic in order to
       break the association with the original shape def when being
       saved.
  <dt> <b>janus-icon-mapping</b> <i>(of a schematic def)</i>
  <dd> A list of <tt>(janus-icon-name . icancad-shape-def)</tt> entries
       that is used to resolve Janus "block icon" names to ICanCAD def
       names.  Both <tt>janus-icon-name</tt> and
       <tt>icancad-shape-def</tt> values are stored as strings.  [Bug:
       this is not updated if an icon is renamed.  -- rgr, 11-Feb-02.]
  <dt> <b>icon-names</b> <i>(of a schematic def)</i>
  <dd> A list of strings naming the icons suggested for use with this
       schematic def.  This is an ICanCAD property generally, and is not
       restricted to Janus defs converted in-place.  [Bug: this is not
       updated if an icon is renamed.  -- rgr, 11-Feb-02.]
</dl>

<a name = primitive>
<h4>Primitive "devices" in ICanCAD</h4>

<p>In ICanCAD, each use has a child, which is normally a schematic, and
an icon.  At the bottom of the hierarchy, once could implement a
primitive device such as a PMOS transistor with a schematic that had
three single-bit port nets and a corresponding icon, but since the
contents of the schematic is entirely determined by the icon, ICanCAD
allows the icon def to be both the child and the icon.  This also
supports top-down design by letting the schematics be created after the
icons.  [need to think about the UI necessary for this.  -- rgr,
14-Jun-01.]

<p>[put note about loose def-to-icon correspondence elsewhere.  -- rgr,
14-Jun-01.]

[Though, to be fully effective, primitive icon defs should have some
special properties defined . . .  -- rgr, 14-Jun-01.]

<p>(Note that even the term "primitive device" is ill-defined; it might
mean one thing to a behavioral simulator, and another thing entirely to
a circuit simulator.)

<a name = revert-def>
<h4>The <tt>revert-def</tt> operation</h4>

In order to replace a loaded def with the disk version, we break it down
into the following steps:
<ol>
  <li> Temporarily rename the def to an arbitrary name that is not in
       use.
  <li> Read the new version using the old name.
  <li> Update all references we can find to the old def with the new
       version.
  <li> Flush the old version permanently.
</ol>

We take pains to choose a def name such that the first step cannot fail,
and by the last step we are pretty much home free.  The third step
shouldn't fail except due to a bug, which would leave the update
incomplete (but there isn't much we can do about that).  [Actually, the
third step is now a NOOP; uses don't require updating.  They don't refer
to def contents at all, which means there are no "dangling references"
that would cause problems later.  Such dangling references caused no end
of problems for Janus.  If we had known enough to avoid such references
altogether, by taking a "snapshot" of the necessary information and
storing it with the use, we would have saved ourselves a great deal of
hassle; the time spent maintaining the code in support of the extra data
structures would have more than paid for itself in time saved fixing
bugs.  (Assuming there aren't drawbacks to this scheme I haven't
encountered yet.)  -- rgr, 28-Apr-02.]

<p>That leaves the second step, re-reading the def, as the key event
during which we must handle failures gracefully.  Fortunately, the
<tt>find-def</tt> code is already pretty robust about cleaning up after
itself in case of unexpected problems.

<a name = part-parent>
<h4>Part parents</h4>

[As in Rel-Janus and New Janus, I initially defined the parent slot of a
part to be nil until the part is first added and after it is deleted,
and a def object while it is a child of the def.  However, as in New
Janus, the fact that deleted parts are potentially kept forever on undo
lists means that deleting a part from one def and adding it to another
cannot be allowed; undoing the deletion would screw up the other def.
So the part really still belongs to the def after it is deleted.  --
rgr, 19-May-01.]

<p>[The <tt>part-deleted?</tt> generic has now been implemented in terms
of <tt>part-parent</tt>; it should be used instead of testing for a null
parent.  When this is done everywhere, the <tt>part-parent</tt> will
<i>never</i> be changed once the part is first added, and
<tt>part-deleted?</tt> will be implemented independently.  This will
allow deleted uses (that may still exist on their parents' undo lists)
to identify correctly the def to which they belong.  -- rgr, 17-Jan-02.]

<p>
<hr>
<a name = issues>
<h3>Random issues</h3>

<a name = inline-user-doc>
<h4>Inline command documentation</h4>

[If command documentation were kept inline, e.g. in the Lisp
<tt>documentation</tt> string of the command function, then we could
provide on-line command help a la emacs.  Better still, we could look up
mouse and menu bindings dynamically, as emacs does, and avoid the hassle
of hardcoding mouse bindings; this may become essential if we really
want to support independent one-button versus two-button mouse binding
schemes.  Best of all, we could make the on-line help searchable.  --
rgr, 15-Jun-01.]

<a name = inline-internal-doc>
<h4>Inline HTML documentation of internals</h4>

It would be really cool to have the stuff in these pages kept in the
Lisp source files, in a manner similar to perl "POD" documentation.
<ul>
  <li> Snippets of HTML could be inserted into Lisp by enclosing them
       between special "#|" and "|#" comments, such as "#|html|" to
       start and "|html|#" to end.  They would then be invisible to
       Lisp, and easy to parse out for HTML.
  <li> Ideally, anchor names defined in inline HTML should be
       hypertextable in both places, i.e. findable in emacs using
       <tt>M-.</tt>, and findable on the Web using the usual "href"
       mechanism.  The <tt>M-.</tt> support will probably require
       supplying some kind of Lisp definition information, such as the
       <tt>define-topic</tt> form used by New Janus, so that the same
       Lisp-based <tt>M-.</tt> mechanism will work for both.
  <li> Better still, anchor references should be "position independent"
       -- if you write <tt>"&lt;a&nbsp;href="#foo"&gt;"</tt>, the
       documentation extractor should elaborate that with the actual
       page reference, as long as the name <tt>foo</tt> is unique.
       (Which it should be anyway, in order to make emacs <tt>M-.</tt>
       work cleanly.)
  <li> Automatic fontification and hyperlinking of Lisp definition names
       would be terrific, e.g. any mention of "add-part" in the
       HTML-within-Lisp source gets turned into <tt>"&lt;a
       href="#add-part"&gt;&lt;tt&gt;add-part&lt;/tt&gt;&lt;/a&gt;"</tt>.
  <li> emacs should indent Lisp using Lisp rules and HTML using HTML
       rules, but getting that to happen when both are interleaved in
       the same buffer will probably be tricky.  (Except emacs 20 was
       supposed to have support for that kind of thing . . . )
</ul>

<p>
<hr>
<address><a href="mailto:rogers@rgrjr.dyndns.org">Bob Rogers
	<tt>&lt;rogers@rgrjr.dyndns.org&gt;</tt></a></address>
<!-- hhmts start -->
Last modified: Sun Apr 28 21:45:59 EDT 2002
<!-- hhmts end -->
</body> </html>
