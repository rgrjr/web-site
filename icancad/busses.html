<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>ICanCAD Schematic Nets and Busses</title>
</head>

<body bgcolor=white>
<h2>ICanCAD Schematic Nets and Busses</h2>

<p><a href="/"><tt>Home</tt></a> : <a href="index.html">ICanCAD</a> :
Schematic Nets and Busses
<hr>

<p>[this is currently being implemented, mostly in the
<tt>extractor.lisp</tt> file.  -- rgr, 13-Jan-03.]

<h3>Table of contents</h3>

<!-- hhmtoc start -->
<ol>
  <li> ICanCAD Schematic Nets and Busses
       <ol>
	 <li> Table of contents
	 <li> <a href="#extraction">Extraction</a>
	      <ol>
		<li> The extraction process
	      </ol>
	 <li> <a href="#netlisting">Netlisting</a>
	      <ol>
		<li> <a href="#hierarchical-netlisting">Hierarchical netlisting</a>
		<li> <a href="#semi-flattening">Flattening versus "semi-flattening"</a>
		<li> <a href="#flattening">Flattening</a>
		<li> Flattening algorithm
	      </ol>
	 <li> <a href="#notes">Connectivity notes</a>
       </ol>
</ol>
<!-- hhmtoc end -->

<a name = extraction>
<h3>Extraction</h3>

<p>[need to say something about how errors are handled.  -- rgr,
21-Mar-01.]

<h4>The extraction process</h4>

[note that bus objects are ephemeral; they are created at need during
the extraction process, and merged when it is later discovered that two
bus objects actually refer to the same bus.  later on, if the def must
be re-extracted, the bus objects are not necessarily reused.  -- rgr,
21-Mar-01.]

<p>[this may be more detail than is needed for user documentation
. . . but on the other hand it may help to have this level of detail
available in case the extractor does something the user doesn't
understand.  most of the hair in here is because we're trying to do the
intuitively reasonable thing, which is rarely straightforward for a
computer.  -- rgr, 21-Mar-01.]

<p><b>Phase I: Bus discovery:</b>

<p>In this phase, we construct a representation of the connectivity
described by physical wiring, and start to annotate this representation
with connections made by name in net labels.

<ol>
  <li> Before extracting a given def, we examine the extraction state of
       all of its children recursively, (re-)extracting them if
       necessary.  We need to do this in order to determine actual port
       widths.  It is convenient to do this before starting to extract
       the local def, since all children must be error-free, and
       changing them should invalidate our cached extraction state.
       <a href="#note1">[1]</a>
  <li> Then, all wiring is scanned to produce bus objects.  A distinct
       bus object is made for each set of connected wires, together with
       their net labels and port connections.  At this point, net labels
       are checked for syntax errors, and their parsed descriptors are
       added to their busses.  By construction, the bus represented by
       each such part set must have a single well-defined width (though
       we don't know what that is yet), and must share the same ordered
       set of nets.  <a href="#note4">[4]</a>
  <li> Next, we look for <a href="connectivity.html#conn">named
       busses</a>.  A name can be assigned to a bus if that name appears
       unsubscripted in a net label such that it spans the width of the
       bus.
  <li> Busses with the same unsubscripted name (as defined above) are
       merged, since the designer must intend them to refer to the same
       thing.  This merging process is transitive; if three busses have
       net labels <tt>"A"</tt>, <tt>"A=B"</tt>, and <tt>"B"</tt>, then
       both names and all three net labels will end up referring to the
       same thing.
</ol>

<p><b>Phase II: Bus width determination:</b>

<p>At this point, bus construction is almost complete (except for the
possible merging in step 9), so the next task is to determine bus
widths.

<ol start="5">
  <li> First, we look for the easy cases where the bus width is
       determined by one of its connected bristles or net labels.
       Specifically, we look for one of the following:
       <ul>
	 <li> an explicit width icon (since width icons are not allowed
	      to have parameterized width values); or
	 <li> a concatenation of explicit subrange specifications (which
	      imply the total number of bits,
	      e.g. <tt>"A&lt;7:0&gt;,B&lt;31:24&gt;"</tt> must be
	      exactly 16 bits wide); or
	 <li> a tap "side" connection (which always has a subrange, as
	      opposed to the "main" connection).
       </ul>
       If more than one such clue to the width can be found, then they
       must all specify the same width (but this is rechecked below
       anyway).  [If there is a conflict, it might in fact be better for
       UI purposes to defer the error until later.  -- rgr, 19-Mar-01.]
  <li> Next, iteration counts are assigned to uses.  If this value has
       not been user-assigned, the iteration count must be the external
       bus width divided by the internal port width, for any and all
       connected busses with defined widths; this division must not
       produce a remainder.  [must be careful here; user-defined
       iteration counts should not be overridden mysteriously.  -- rgr,
       18-Mar-01.]  [currently, we do this poorly.  -- rgr, 13-Jan-03.]
  <li> Once all use iterations are known, the ports of each use can be
       checked for width consistency.  (Taps and rippers are ignored
       during this step.)  This may result in solving previously unknown
       widths for connected busses.  [Or this might really be part of
       the previous step.  It might be necessary to iterate between bus
       width and use iteration determination in order to propagate such
       constraints.  -- rgr, 18-Jan-03.]
  <li> If there are still any remaining busses with unknown widths at
       this point, they are assigned the width of 1.  [I think this will
       always be successful.  -- rgr, 18-Mar-01.]  And once the widths
       are known, each bus's net labels and use connections can then be
       checked for width consistency.
  <li> It may now be possible to find additional bus names.  For
       example, consider a bus labelled <tt>B&lt;7:0&gt;</tt>.
       <ul>
	 <li> If there is no physical bus named <tt>B</tt> anywhere,
	      then <tt>B&lt;7:0&gt;</tt> can be given that name, since
	      the subscripts are strictly redundant.
	 <li> If a bus <tt>B</tt> exists, and it is 8 bits wide, then
	      the two busses can be merged.  [modulo endian issues; the
	      order of bits must match for this to work.  -- rgr,
	      21-Mar-01.]
	 <li> If a bus <tt>B</tt> exists but is less than 8 bits wide,
	      then that is an error.
       </ul>
       Note that this is the only time we merge busses after
       we've started determining bus widths, and we only do it to busses
       of the same width.  Consequently, bus
  <li> At this point, the set of busses is complete, so we can analyze
       them for consistency.
       <ul>
	 <li> The bus' net labels determine its <a
	      href="connectivity.html#context">signal context</a>.  An
	      error is flagged if a given bus has both a net label that
	      declares <tt>:global</tt> context and another net label
	      that declares <tt>:port</tt> context, but neither of those
	      conflict with any net labels that declare <tt>:local</tt>
	      context.  <a href='#note6'>[6]</a>
	 <li> All bus names are known, and so it is possible to choose
	      one name for each bus to serve as its primary name.
	      Preference is given first to names declared on net labels
	      with <tt>:global</tt> context, then to names declared on
	      net labels with <a href="connectivity.html#context"><tt>:port</tt>
	      context</a>, and finally to <tt>:local</tt> labels; within
	      the same context rank, names that appear earlier in
	      alphabetical sequence are preferred over later names.  <a
	      href='#note2'>[2]</a>
	 <li> We also check that there are no subscripted references for
	      which a named bus does not exist.  For example, if
	      <tt>"xyzzy&lt;11&gt;"</tt> appears somewhere, there must
	      be an <tt>"xyzzy"</tt> defined somewhere else that is at
	      least 12 bits wide.  <a href="#note3">[3]</a>
       </ul>
       [these checks are not yet done as described.  -- rgr, 15-Jan-03.]
</ol>

<p><b>Phase III: Net creation:</b>

<p>At this point, the set of busses are complete, but much of the
described connectivity may still be implicit in net label and tap
subscript reference.  So it remains to create net objects for each bit
of each bus in such a way as to make this information explicit.

<ol start="11">
  <li> Each bit position of each bus is then filled with a <a
       href="glossary.html#net">net</a> object that represents the bit,
       and merging this with any other nets found in corresponding
       posititions of all net label specifications.  This is actually
       done in three steps (for each bit position):
       <ol>
	 <li> For each net label specification, look for a
	      with the net at the corresponding position.
	 <li> If no such net was found, create a new one; in any case,
	      assign the resulting net to the bus' bit position.
	 <li> For each net label specification, assign the net to the
	      corresponding position of the referenced bus, merging the
	      net objects if necessary.
       </ol>
       Step 3 must always be done, since net label specs are rarely
       symmetric; if this bus doesn't do it, the other bus is not likely
       to know it should be using the same bit.  The "assign before
       propagation" rule ensures that circular references do not cause
       problems.
  <li> Then, port and global nets are identified.
       <ol>
	 <li> Each net label that declares <tt>:global</tt> context is
	      checked to see that
	      <dl compact>
		<dt> (a)
		<dd> the connected bus is one bit wide; and
		<dt> (b)
		<dd> its net has a single name, which is made the net's
		     global name.
	      </dl>
	      These nets are then marked as globals.
	 <li> Each net label that declares <tt>:port</tt> context gets
	      all of its bits marked as such.  If a net is already
	      marked as global, that is flagged as an error.
       </ol>
       All remaining nets must be local; being the default, any
       <tt>:local</tt> declarations can be ignored.
  <li> Local nets that are still not connected to anything are probably
       in error; they are brought to the user's attention, and removed
       from the list of nets.  <a href="#note7">[7]</a> [this item is
       new, and messes up the numbering.  -- rgr, 17-Jan-03.]
  <li> Global nets in each of the immediate children are then checked to
       see whether nets of the same global name exist in the parent.  If
       there are no such nets, then "virtual" global nets must be
       created for them.  [this item is also new.  -- rgr, 22-Jan-03.]
  <li> Finally, nets are assigned names.  Busses of width 1 lend their
       names to their nets.  Nets that do not otherwise have a name are
       assigned generated names such as <tt>"NET1"</tt>,
       <tt>"NET2"</tt>, etc.  [currently, that's all we do, which is
       inadequate.  -- rgr, 15-Jan-03.]
</ol>

<a name="netlisting">
<h3>Netlisting</h3>

There are two traditional ways to obtain a netlist from a schematic:
<ul>
  <li> Hierarchical, where the structure of the netlist mirrors the
       structure of the schematic hierarchy; and
  <li> Flattened, where all hierarchical information is thrown away.
</ul>
Hierarchical netlists contain more information, and their correspondence
to the schematics from which they come naturally makes it easier to map
information gleaned from simulation back to the source.  But flat
netlists also have their place; for instance, when doing LVS, the
circuit extracted from the layout comes back as a flat netlist,
requiring a flat-vs-flat comparison.

<p>ICanCAD supports an intermediate form of netlisting called
"semi-flattening", which replaces each schematic with parameters by a
set of fixed-parameter schematics, one for each unique combination that
appears in the design, with all parameters values on uses replaced with
constants.  This eliminates the need to pass parameters in netlist
subcircuit calls, while still preserving the hierarchical structure of
the original design, and retaining shared hierarchy to the greatest
extent possible.

<a name="hierarchical-netlisting">
<h4>Hierarchical netlisting</h4>

Hierarchical netlisting uses a straightforward mapping between schematic
nets and uses on the one hand, and circuit nodes and subcircuits or
devices on the other.

<p>If a use has two or more iterations, it results in the corresponding
number of subcircuit calls; in this case, each iteration is
distinguished with an underscore followed by the iteration number after
the use name.  As for bus subscripts, use iteration "subscripts" are
always zero-based.

<p>Global nets must be treated specially [as usual], since most netlist
formats do not support globals, so global nets are usually output as an
extra set of ports.  [finish.  -- rgr, 17-Jan-03.]

<a name="semi-flattening">
<h4>Flattening versus "semi-flattening"</h4>

<p>[In NS, Janus, and New Janus, flattened networks were important
because few simulators (if any) could handle the full power of <a
href="general.html#schematic-parameters"> Lisp-embedded schematic
parameter passing</a> -- and even for those that potentially could, the
problem of converting Lisp parameter expressions into whatever syntax
the simulator required was daunting.  So, networks were flattened for
simulation, and the user interfaces took care of presenting flat names
in simulation results in hierarchical terms.
Unfortunately, flattening makes the simulator's native interface almost
impossible to use, and hierarchical netlists are much more familiar to
designers.  There is still no general solution to the translation
problem, so we are pushing the use of a "semi-flat" representation.
Flattening will still be useful within ICanCAD -- after all, 
simulators flatten their hierarchical netlists internally anyway -- but
will probably not be as important.  -- rgr, 17-Jan-03.]

<p>[must try to use the same scheme for mapping names to parameter
bindings as for EDIF semi-flattening.  -- rgr, 17-Jan-03.]

<a name = flattening>
<h4>Flattening</h4>

<p>"Flattening" is the process that produces an ICanCAD <a
href="glossary.html#network">network object</a> from a given top-level
def.  In order to do this, ICanCAD must traverse the hierarchy starting
from the given def, creating new nodes for new local nets in each
schematic, and propagating connections down into lower hierarchical
levels.  At the bottom of the hierarchy, devices are created to
represent primitives.  The resulting network therefore consists only of
nodes connected to devices, with a smattering of additional data
structures to describe node &lt;-&gt; net and use &lt;-&gt; device
correspondences for UI purposes.  All of the net/bus/port structure has
been abstracted away, and all of the circuit inclusion implied by the
uses has been made explicit in the form of low-level devices directly
connected through nodes.

<p>Perhaps more important, any parameterization will have been "fixed"
by ICanCAD into whatever device parameter values are appropriate.  This
is why ICanCAD does not require simulators to support a hierarchical
netlist input format with parameter passing; ICanCAD does all the work
of parameterization during flattening.

<p>[We need a good way of specifing where to stop flattening for
high-level things like functional simulation.  Rel-Janus simply stopped
when it got to something that had a model defined (and primitives were
special-cased); there was no other user-level control mechanism.  New
Janus had a fairly general mechanism, based on def-name patterns, but it
was rather cumbersome.  Something that lends itself to a simple,
intuitive GUI and produces a data structure that can be saved with the
top-level def would be ideal.  -- rgr, 23-Mar-01.]

<h4>Flattening algorithm</h4>

[yeah, this is really internal documentation . . . at least this is
easier than extraction.  -- rgr, 21-Mar-01.]

<ol>
  <li> Walk the hierarchy performing extractions.  Give up if any
       produce errors.  Only needs to visit each def exactly once.
  <li> For all of the top-level def's nets, create a node object.
  <li> Recur into each use, filling the port and global nets with node
       objects from the parent def's connected nets.  (Rel-Janus and New
       Janus each had some API call to do the port mapping, but I have
       forgotten them both.)  Then, create new nodes for each local net,
       and continue the hierarchical recursion.
  <li> At the level of primitive defs, create a device object and make
       its connections using the same port-mapping technique.
</ol>

Occasionally it may be necessary to merge nodes, since ports that appear
to be distinct at the top of the hierarchy may be shorted down below.
But this will happen much less frequently than for nets that need to be
merged, since there are a multitude of nonobvious ways to "short" nets.

<a name='notes'>
<h3>Connectivity notes</h3>

<dl compact>
  <dt> [1]
  <dd> <a name='note1'> We might be able to minimize def recursion
       during extraction by saving some indication of port widths and
       global names along with each schematic def.  We would only need
       to re-extract if we couldn't find the cache, perhaps because the
       schematic was saved without fixing an extraction error.  On the
       other hand, we'd still have to load the entire hierarchy anyway,
       so maybe this wouldn't pay.

  <dt> [2]
  <dd> <a name='note2'> The choice of a primary bus name is purely for
       user interface purposes, and for output when generating netlists;
       the other names are always valid.  However, this choice must be
       repeatable in order to make testing manageable.

  <dt> [3]
  <dd> <a name='note3'> If we didn't treat this as an error, then we
       would have to make the bits for <tt>xyzzy&lt;10:0&gt;</tt> exist,
       but they wouldn't be connected to anything, which is rather
       pointless.  Or, we could skip creating them, but then the value
       of 11 for the subscript is meaningless.  Either way, this is most
       likely a net label typo or other similar error, and should be
       reported as such.

  <dt> [4]
  <dd> <a name='note4'>At this point, feedthroughs are accommodated by
       treating as connected any subset of bristles that share the same
       port name -- but using <tt>string-equal</tt> instead of parsing
       the name, which is probably a mistake.

  <dt> [6]
  <dd> <a name='note6'>
       In practice, busses don't store context, though nets do.  So we
       don't actually check or compute the bus context until we create
       the nets.

  <dt> [7]
  <dd> <a name='note7'> The check for unconnected nets is not
       implemented yet.  In order to check this hierarchically, we need
       to see if any of its busses go to bristles on uses that are not
       declared as <a href="connectivity.html#special-devices">special
       devices</a>.  [However, <tt>net-busses</tt> is not kept up to
       date currently.  -- rgr, 17-Jan-03.]  Ideally, "not connected"
       should mean that the net doesn't show up in any Spice netlist,
       because it doesn't have any "real" device connections (in the
       flat sense).  Removal of unused nets is therefore desirable,
       because it saves us from creating useless nodes when flattening,
       but could be problematic, because it's not obvious what to do
       with the busses that gave rise to them.
</dl>

<p>
<hr>
<address><a href="mailto:rogers@rgrjr.dyndns.org">Bob Rogers
	<tt>&lt;rogers@rgrjr.dyndns.org&gt;</tt></a></address>
<!-- hhmts start -->
Last modified: Wed Jan 22 21:24:19 EST 2003
<!-- hhmts end -->
</body> </html>
